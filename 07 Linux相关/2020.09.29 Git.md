# Git

学习路径：[Git大全](https://gitee.com/all-about-git)、[廖雪峰 | Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

## 版本控制

**版本控制（Revision control**）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。

- 实现跨区域多人协同开发
- 追踪和记载一个或者多个文件的历史记录
- 组织和保护你的源代码和文档
- 统计工作量
- 并行开发、提高开发效率
- 跟踪记录整个软件的开发过程
- 减轻开发人员的负担，节省时间，同时降低人为错误

简单说就是用于管理多人协同开发项目的技术。

没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。

无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！

### 常见的版本控制工具

主流的版本控制器有如下这些：

- **Git**
- **SVN（Subversion）**
- CVS（Concurrent Versions System）
- VSS（Micorosoft Visual SourceSafe）
- TFS（Team Foundation Server）
- Visual Studio Online

版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN。

### 版本控制分类

#### 1、本地版本控制

记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。

![image-20200929142129540](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929142129.png)

#### 2、集中版本控制  SVN

所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改

![image-20200929142245575](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929142245.png)

所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS。

#### 3、分布式版本控制Git

所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。

![image-20200929142419285](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929142419.png)

好处：不会因为服务器损坏或者网络问题，造成不能工作的情况！

坏处：每个人都拥有全部的代码！安全隐患！

### Git与SVN的主要区别

SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。

![image-20200929142610383](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929142610.png)

Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！

Git是目前世界上最先进的分布式版本控制系统。

## Git环境配置

### 软件下载

打开 [git官网](https://git-scm.com/)，下载git对应操作系统的版本。所有东西下载慢的话就可以去找镜像！官网下载太慢，我们可以使用[淘宝镜像](http://npm.taobao.org/mirrors/git-for-windows/)下载：

![image-20200929143301603](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929143301.png)

### 启动Git

安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！

![image-20200929143657645](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929143657.png)

Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多

Git CMD：Windows风格的命令行

Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

### 常用的Linux命令

1. cd : 改变目录。

2. cd . . 回退到上一个目录，直接cd进入默认目录

3. pwd : 显示当前所在的目录路径。

4. ls(ll):  都是列出当前目录中的所有文件，只不过ll列出的内容更为详细。

5. touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。

6. rm:  删除一个文件, rm index.js 就会把index.js文件删除。

7. mkdir:  新建一个目录,就是新建一个文件夹。

8. rm -r :  删除一个文件夹, rm -r src 删除src目录

```shell
rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！
```

9. mv 移动文件， mv index.html src index.html 是我们要移动的文件，src 是目标文件夹，当然, 这样写,必须保证文件和目标文件夹在同一目录下。

10. reset 重新初始化终端/清屏。

11. clear 清屏。

12. history 查看命令历史。

13. help 帮助。

14. exit 退出。

### Git 配置

所有的配置文件，其实都保存在本地！

- 查看配置 `git config -l`

- ```bash
  $ git config -l
  
  diff.astextplain.textconv=astextplain
  filter.lfs.clean=git-lfs clean -- %f
  filter.lfs.smudge=git-lfs smudge -- %f
  filter.lfs.process=git-lfs filter-process
  filter.lfs.required=true
  http.sslbackend=openssl
  http.sslcainfo=D:/DevelopmentTools/Git/mingw64/ssl/certs/ca-bundle.crt
  core.autocrlf=true
  core.fscache=true
  core.symlinks=false
  pull.rebase=false
  credential.helper=manager
  user.name=Reanon
  user.email=793584285@qq.com
  ```

查看不同级别的配置文件

- 查看系统config：`git config --system --list`
- 查看当前用户（global）配置：`git config --global  --list`

```shell
$ git config --system --list
diff.astextplain.textconv=astextplain
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
filter.lfs.process=git-lfs filter-process
filter.lfs.required=true
http.sslbackend=openssl
http.sslcainfo=D:/DevelopmentTools/Git/mingw64/ssl/certs/ca-bundle.crt
core.autocrlf=true
core.fscache=true
core.symlinks=false
pull.rebase=false
credential.helper=manager

$ git config --global  --list
user.name=Reanon
user.email=793584285@qq.com

```

#### Git相关的配置文件

1. Git 安装目录下的 gitconfig：`..\Git\etc\gitconfig`   --system 系统级
2. 只适用于当前登录用户的配置：`C:\Users\Administrator\.gitconfig`   --global 全局
   1. Git显示颜色，会让命令输出看起来更醒目：`git config --global color.ui true`

--system 系统级

![image-20200929145328711](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929145328.png)

 --global 全局

![image-20200929145429690](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929145429.png)

#### 设置用户名与邮箱（必要）

当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：

```shell
# 名称
git config --global user.name "reanon"  
# 邮箱
git config --global user.email 793584285@qq.com   
```

```bash
# 查看配置
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop
$ git config --global user.name "reanon"

Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop
$ git config --global user.email 793584285@qq.com

Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop
$ git config --global --list
user.name=reanon
user.email=793584285@qq.com
```

只需要做一次这个设置，如果你传递了`--global` 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。

如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要`--global`选项。总之`--global`为全局配置，不加为某个项目的特定配置。

## Git基本理论

Git本地有四个工作区域：

- 工作目录（Working Directory）：就是平时存放项目代码的地方
- 暂存区(Stage/Index)：用于临时存放你的改动，**事实上它只是一个文件**，保存即将提交到文件列表信息
- 资源库(Repository或Git Directory)：就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本
- 远程的git仓库(Remote Directory)：托管代码的服务器，可以简单的认为是项目组中的一台电脑用于远程数据交换

文件在这四个区域之间的转换关系如下：

![image-20200929150152075](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929150152.png)

本地的三个区域确切的说应该是git仓库中HEAD指向的版本：

![image-20200929150848594](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929150848.png)

- Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。
- WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。
- .git：是隐藏文件夹，存放Git管理信息的目录，初始化仓库的时候自动创建。
- Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。
- Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。
- Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。

## Git工作流程

git的工作流程一般是这样的：

1. 在工作目录中添加、修改文件；
2. 将需要进行版本管理的文件放入暂存区域；
3. 将暂存区域的文件提交到git仓库。

因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)

![git之概念图](https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xMzY4OTYxLzIwMTkwMy8xMzY4OTYxLTIwMTkwMzI1MDkzODI4NjU0LTU3ODU3MzY1NC5wbmc=.jpg)

### 多人协同

#### 查看信息

```shell
# 显示更详细的信息
$ git remote -v
origin  git@github.com:Reanon/learngit.git (fetch)
origin  git@github.com:Reanon/learngit.git (push)

# 推送分支
$ git push origin master
# 推送其他分支
$ git push origin dev
```

#### 分支推送

1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；

- `master`分支是主分支，因此要时刻与远程同步；
- `dev`分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

#### 抓取分支

多人协作时，大家都会往`master`和`dev`分支上推送各自的修改。从远程库clone时，默认情况下，只能看到本地的`master`分支

```shell
# 克隆一个项目
$ git clone git@github.com:Reanon/learngit.git
Cloning into 'learngit'...
remote: Enumerating objects: 35, done.
remote: Counting objects: 100% (35/35), done.
remote: Compressing objects: 100% (21/21), done.
remote: Total 35 (delta 11), reused 34 (delta 10), pack-reused 0
Receiving objects: 100% (35/35), done.
Resolving deltas: 100% (11/11), done.
# 只有master
$ git branch
* master
# 创建远程origin的dev分支到本地
$ git checkout -b dev origin/dev
Switched to a new branch 'dev'
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
# dev已经出现在本地
$ git branch
* dev
  master
# 在dev上继续修改，然后，时不时地把dev分支push到远程
$ touch env.txt
$ git add env.txt
$ git commit -m "add env"
[dev e0e10ae] add env
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 env.txt
# 推送到远程的dev分支上
$ git push origin dev
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Delta compression using up to 8 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 219 bytes | 219.00 KiB/s, done.
Total 2 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:Reanon/learngit.git
   6164630..e0e10ae  dev -> dev

```

你的小伙伴已经向`origin/dev`分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。

```shell
# 回到自己工作目录，尝试推送。
$ vim env.txt

$ git add env.txt
warning: LF will be replaced by CRLF in env.txt.
The file will have its original line endings in your working directory

$ git commit -m "add new env"
[dev 881606d] add new env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt
# 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突
$ git push origin dev
Warning: Permanently added the RSA host key for IP address '52.74.223.119' to the list of known hosts.
To github.com:Reanon/learngit.git
 ! [rejected]        dev -> dev (fetch first)
error: failed to push some refs to 'github.com:Reanon/learngit.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
# 创建链接
$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
# 再次拉取,得到冲突
$ git pull
CONFLICT (add/add): Merge conflict in env.txt
Auto-merging env.txt
Automatic merge failed; fix conflicts and then commit the result.
# 查看冲突，解决冲突
$ git status
On branch dev
Your branch and 'origin/dev' have diverged,
and have 1 and 2 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both added:      env.txt

no changes added to commit (use "git add" and/or "git commit -a")
# 解决冲突，再次提交
$ vim env.txt
$ git add env.txt

Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (dev|MERGING)
$ git commit -m "fix env conflict"
[dev c00a820] fix env conflict

Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (dev)
$ git push origin dev
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 623 bytes | 623.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:Reanon/learngit.git
   7087f1c..c00a820  dev -> dev

```

先用`git pull`把最新的提交从`origin/dev`抓下来，然后，在本地合并，解决冲突，再推送

```shell
# git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接
$ git pull
remote: Enumerating objects: 6, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 5 (delta 1), reused 5 (delta 1), pack-reused 0
Unpacking objects: 100% (5/5), 479 bytes | 11.00 KiB/s, done.
From github.com:Reanon/learngit
   6164630..7087f1c  dev        -> origin/dev
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> dev

# 设置dev和origin/dev的链接
$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
```



1. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；
2. 如果合并有冲突，则解决冲突，并在本地提交；
3. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！

如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`。

这就是多人协作的工作模式，一旦熟悉了，就非常简单。

## Git文件操作

### 文件的四种状态

版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。

- `Untracked`: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过`git add` 状态变为`Staged`
- `Unmodify`: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处：
  - 如果它被修改, 而变为`Modified`
  - 如果使用`git rm`移出版本库, 则成为`Untracked`文件
- Modified: 文件已修改，仅仅是修改, 并没有进行其他的操作。 这个文件也有两个去处,
  - 通过`git add`可进入暂存`staged`状态
  - 使用`git checkout` 则丢弃修改， 返回到unmodify状态
  - `git checkou`：t即从库中取出文件, 覆盖当前修改 
- Staged: 暂存状态。执行`git commit`则将修改同步到库中，这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行`git reset HEAD filename`取消暂存, 文件状态为Modified

### 查看文件状态

- 查看指定文件状态：`git status [filename]`
- 查看所有文件状态：`git status`
- 添加所有文件到暂存区：`git add .`              
- 提交暂存区中的内容到本地仓库：`git commit -m "消息内容"`
  - -m 提交信息

```shelL
# 新建仓库
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/gittest
$ git init
Initialized empty Git repository in D:/Desktop/gittest/.git/

# 新建文件
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/gittest (master)
$ touch hello.txt

# 查看状态
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/gittest (master)
$ git status hello.txt
On branch master
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        hello.txt
nothing added to commit but untracked files present (use "git add" to track)

# 添加文件到暂存区
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/gittest (master)
$ git add .
# 提交文件到本地仓库
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/gittest (master)
$ git commit -m "new file hello.txt"
[master (root-commit) a2bcfca] new file hello.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 hello.txt

# 再次查看状态
Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/gittest (master)
$ git status
On branch master
nothing to commit, working tree clean

```

### ignore文件

有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等；可以在[GitHub配置忽略文件](https://github.com/github/gitignore)的原则是：

1. 忽略操作系统自动生成的文件，比如缩略图等；
2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的`.class`文件；
3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。

#### .igore规则

在主目录下建立`.gitignore`文件，此文件有如下规则：

1. 忽略文件中的空行或以井号（#）开始的行将会被忽略。

2. 可以使用Linux通配符。
   - `*`：星号，代表任意多个字符
   - `？`：问号，代表一个字符
   - `[abc]`：方括号，代表可选字符范围
   - `{string1,string2,...}`：花括号，代表可选的字符串等。
   
3. `!`：名称的最前面有一个感叹号，表示例外规则，将不被忽略。

4. `/`：分为三种情况：
   
   1. 名称的**最前面**是一个路径分隔符，表示要忽略的文件在此目录下，而子目录中的文件不忽略。
   2. 名称的**最后面**是一个路径分隔符，表示要忽略的是此目录下该名称的子目录，其所有文件和子目录也将被忽略。
   3. 不是以斜杠开头，则它将匹配任何目录或子目录中的文件和目录。
   
   | 模式          | 匹配示例                                             |
   | ------------- | ---------------------------------------------------- |
   | `/access.log` | `access.log`                                         |
   | `access.log`  | `access.log` `logs/access.log` `var/logs/access.log` |
   | `build/`      | `build`                                              |

```shell
#为注释
# 忽略 node_modules 目录
node_modules/
# 忽略日志
logs
*.log
# 忽略构建目录
/dist
# 忽略环境变量目录
.env
# 忽略 IDE 设置
.idea/
.vscode/
*.sw*
# Pytharm
.idea/
*.iml
out/
gen/
```

#### git check-ignore

- `git check-ignore-v [file]`：命令检查哪个规则写错

  ```
  # 发现无法添加.class文件
  $ git add APP.class
  The following paths are ignored by one of your .gitignore files:
  APP.class
  hint: Use -f if you really want to add them.
  hint: Turn this message off by running
  hint: "git config advice.addIgnoredFile false"
  
  # 查看.gitignore规则
  $ git check-ignore -v App.class
  .gitignore:17:*.class   App.class
  ```

  

## Git常用指令

![git之概念图](https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xMzY4OTYxLzIwMTkwMy8xMzY4OTYxLTIwMTkwMzI1MDkzODI4NjU0LTU3ODU3MzY1NC5wbmc=.jpg)

### 仓库

#### git init

- `git init`：在当前目录新建一个Git代码库
- `git init [project-name]`：新建一个目录，将其初始化为Git代码库

#### git clone

默认的`git://`使用ssh，但也可以使用`https`等其他协议；使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令；但是在某些只开放http端口的公司内部就无法使用`ssh`协议而只能用`https`。

- `git clone [url]`：下载一个项目和它的整个代码历史

###  配置

#### git config

- `git config --list`：显示当前的Git配置
- `git config -e [--global]`：编辑Git配置文件
- 设置提交代码时的用户信息：
  - `git config [--global] user.name "[name]"`：带上名字
  - `git config [--global] user.email "[email address]"`：带上邮箱

### 增加/删除文件

#### git add

- `git add [file1] [file2] ...`：添加指定文件到暂存区

  ```shell
  # 修改了一个文件，新建了一个文件，查看状态
  $ git status
  On branch master
  Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
          modified:   readme.txt
  
  Untracked files:
    (use "git add <file>..." to include in what will be committed)
          LICENSE
  
  no changes added to commit (use "git add" and/or "git commit -a")
  
  # 添加两个文件
  $ git add readme.txt LICENSE
  
  # 再次查看状态
  $ git status
  On branch master
  Changes to be committed:
    (use "git restore --staged <file>..." to unstage)
          new file:   LICENSE
          modified:   readme.txt
  # 提交修改
  $ git commit -m "understand how stage works"
  [master e95e52b] understand how stage works
   2 files changed, 1 insertion(+)
   create mode 100644 LICENSE
  
  ```

- `git add .`：添加当前目录的所有文件到暂存区

- `git add [dir]`：添加指定目录到暂存区，包括子目录

- `git add -p`：添加每个变化前，都会要求确认；对于同一个文件的多处变化，可以实现分次提交

#### git rm

- `git rm [file1] [file2] ...`：删除工作区文件，并且将这次删除放入暂存区
- `git rm --cached [file]`：停止追踪指定文件，但该文件会保留在工作区

#### git mv

- `git mv [file-original] [file-renamed]`：改名文件，并且将这个改名放入暂存区

### 代码提交

#### git commit

- `git commit -m [message]`：提交暂存区到仓库区
- `git commit [file1] [file2] ... -m [message]`：提交暂存区的指定文件到仓库区：
- `git commit -a`：提交工作区自上次commit之后的变化，直接到仓库区
- `git commit -v`：提交时显示所有diff信息
- `git commit --amend [file1] [file2] ...`：重做上一次commit，并包括指定文件的新变化
- `git commit --amend -m [message]`：使用一次新的commit，替代上一次提交；如果代码没有任何新变化，则用来改写上一次commit的提交信息

### 分支

#### git branch

查看分支

- `git branch`：列出所有本地分支

  ```shell
  $ git branch
  * dev
    master
  ```

- `git branch -r`：列出所有远程分支

- `git branch -a`：列出所有本地分支和远程分支

  ```shell
  $ git branch -a
  * dev
    master
    remotes/gitee/dev
    remotes/gitee/master
    remotes/github/master
  
  ```

  

新建分支

- `git branch [branch-name]`：新建一个分支，但依然停留在当前分支

- `git branch [branch] [commit]`：新建一个分支，指向指定commit

- `git branch --track [branch] [remote-branch]`：新建一个分支，与指定的远程分支建立追踪关系

- `git branch --set-upstream-to <branch-name> origin/<branch-name>`：创建本地分支和远程分支的链接关系

  - 当`git pull`提示`no tracking information`，可以使用此命令。

  ```shell
  $ git pull
  remote: Enumerating objects: 6, done.
  remote: Counting objects: 100% (6/6), done.
  remote: Compressing objects: 100% (3/3), done.
  remote: Total 5 (delta 1), reused 5 (delta 1), pack-reused 0
  Unpacking objects: 100% (5/5), 479 bytes | 11.00 KiB/s, done.
  From github.com:Reanon/learngit
     6164630..7087f1c  dev        -> origin/dev
  There is no tracking information for the current branch.
  Please specify which branch you want to merge with.
  See git-pull(1) for details.
  
      git pull <remote> <branch>
  
  If you wish to set tracking information for this branch you can do so with:
  
      git branch --set-upstream-to=origin/<branch> dev
  # 创建链接
  $ git branch --set-upstream-to=origin/dev dev
  Branch 'dev' set up to track remote branch 'dev' from 'origin'.
  # 再次拉取,得到冲突
  $ git pull
  CONFLICT (add/add): Merge conflict in env.txt
  Auto-merging env.txt
  Automatic merge failed; fix conflicts and then commit the result.
  ```

  

删除分支

- `git branch -d [branch-name]`：删除分支

- `git branch -D [branch-name]`：如果要丢弃一个没有被合并过的分支，则需要强行删除

  ```shell
  # 未合并删除失败
  $ git branch -d feature-vulcan
  error: The branch 'feature-vulcan' is not fully merged.
  If you are sure you want to delete it, run 'git branch -D feature-vulcan'.
  # 要强行删除，需要使用大写的-D参数
  Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (dev)
  $ git branch -D feature-vulcan
  Deleted branch feature-vulcan (was 1aa8f47).
  
  ```

- `git branch -dr [remote/branch]`：删除远程分支

#### git push

- git push origin --delete [branch-name]：删除远程分支

切换分支

#### git checkout

- `git checkout [name]`：切换到指定分支，并更新工作区

- `git checkout -`：切换到上一个分支

- `git checkout -b [branch]`：新建一个分支，并切换到该分支
  
  - 相当于：`git branch [branch]` + `git checkout [branch]`
  
  ```shell
  # 创建并切换分支
  $ git checkout -b dev
  Switched to a new branch 'dev'
  
  # 查看分支
  $ git branch
  * dev
    master
  ```
  
- `git checkout -b [branch][tag]`：新建一个分支，指向某个tag

- `git checkout -b dev(本地分支名称) origin/dev(远程分支名称)` ：在本地创建分支dev并切换到该分支

#### git switch

- git switch -c [name]：创建并切换分支

  ```
  $ git switch -c feature1
  Switched to a new branch 'feature1'git 
  ```

- git switch [name]：切换已有的分支

合并分支

#### git merge

- `git merge [branch]`：合并指定分支到当前分支

- `git merge --no-ff  [branch]`：合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。

  ```shell
  # 查看未合并前文档
  $ cat readme.txt
  
  Git is a version control systeam.
  Git is free software under the GPL.
  Git has a mutable index called stage.
  Git tracks changes.
  
  # 合并分支
  $ git merge dev
  Updating ffb8573..ea7ef7d
  Fast-forward
   readme.txt | 1 +
   test.txt   | 0
   2 files changed, 1 insertion(+)
   create mode 100644 test.txt
  
  # 再次查看文档
  $ cat readme.txt
  
  Git is a version control systeam.
  Git is free software under the GPL.
  Git has a mutable index called stage.
  Git tracks changes.
  Creating a new branch is quick.
  
  # 删除分支
  $ git branch -d dev
  Deleted branch dev (was ea7ef7d).
  
  # 删除后，查看branch，就只剩下master分支了
  $ git branch
  * master
  ```

- 解决冲突

  - Git用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容

- ![image-20201002215228206](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201002215228.png)

  ```shell
  $ git branch
    feature1
  * master
  
  # 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看
  $ git merge feature1
  Auto-merging readme.txt
  CONFLICT (content): Merge conflict in readme.txt
  Automatic merge failed; fix conflicts and then commit the result.
  
  # 查看当前状态：Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交
  $ git status
  On branch master
  Your branch is ahead of 'origin/master' by 2 commits.
    (use "git push" to publish your local commits)
  
  You have unmerged paths.
    (fix conflicts and run "git commit")
    (use "git merge --abort" to abort the merge)
  
  Unmerged paths:
    (use "git add <file>..." to mark resolution)
          both modified:   readme.txt
  
  no changes added to commit (use "git add" and/or "git commit -a")
  
  # 查看冲突文件
  $ cat readme.txt
  Git is a version control systeam.
  Git is free software under the GPL.
  Git has a mutable index called stage.
  Git tracks changes.
  Creating a new branch is quick.
  <<<<<<< HEAD
  Creating a new branch is quick & simple.
  =======
  Creating a new branch is quick AND simple.
  >>>>>>> feature1
  
  # 手动修改文件
  $ vim readme.txt
  # 再提交
  $ git add readme.txt
  $ git commit -m "conflict fix"
  [master 46cb0c9] conflict fix
  
  # 删除分支
  $ git branch -d feature1
  Deleted branch feature1 (was a1be216)
  ```

- 现在，master分支和feature1分支变成了下图所示：

  ![image-20201002215725807](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201002215725.png)

- `git merge --no-ff  [branch]`：

  ```shell
  # 仍然创建并切换dev分支
  $ git switch -c dev
  Switched to a new branch 'dev'
  
  # 修改readme.txt文件，并提交一个新的commit
  $ vim readme.txt
  $ git add readme.txt
  $ git commit -m "add merge"
  [dev 18d1024] add merge
   1 file changed, 1 insertion(+)
  
  # 我们切换回master
  $ git switch master
  Switched to branch 'master'
  Your branch is ahead of 'origin/master' by 4 commits.
    (use "git push" to publish your local commits)
  # 本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
  $ git merge --no-ff -m "merge with no-ff" dev
  Merge made by the 'recursive' strategy.
   readme.txt | 1 +
   1 file changed, 1 insertion(+)
   
  # 合并后，我们用git log看看分支历史
  $ git log --graph --pretty=oneline --abbrev-commit
  *   12e98f0 (HEAD -> master) merge with no-ff
  |\
  | * 18d1024 (dev) add merge
  |/
  *   46cb0c9 conflict fix
  |\
  | * a1be216 AND simple
  * | 2a96c7e & simple
  |/
  * ea7ef7d branch test
  * ffb8573 (origin/master) git changes
  * e95e52b understand how stage works
  * 5b382a6 append GPL
  * df126b3 modify readme.txt
  * da1bff0 wrote a readme file
  ```

  ![image-20201002221413600](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201002221413.png)

#### git cherry-pick

- `git cherry-pick [commit]`：选择一个commit，合并进当前分支；在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick <commit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。

  ```shell
  # 在主分支上查看日志找到bug修复的commit id
  Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (master)
  $ git log -10 --pretty=oneline
  3c7ed8d041d8557763784743a3d57a1def6b1159 (HEAD -> master) merged bug fix 101
  0c3b23eec90bf2bfe9699c7a9ca65a7d0047b4b2 bug fix
  ...
  
  # 切换到dev
  Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (master)
  $ git switch dev
  Switched to branch 'dev'
  
  # 用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。会提示有冲突
  Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (dev)
  $ git cherry-pick 0c3b23eec90bf2bfe9
  Auto-merging readme.txt
  CONFLICT (content): Merge conflict in readme.txt
  error: could not apply 0c3b23e... bug fix
  hint: after resolving the conflicts, mark the corrected paths
  hint: with 'git add <paths>' or 'git rm <paths>'
  hint: and commit the result with 'git commit'
  
  # 解决冲突文件
  Reanon@DESKTOP-JUFDSD1 MINGW64 /d/Desktop/learngit (dev|CHERRY-PICKING)
  $ vim readme.txt
  
  ```

  

### 标签

#### git tag

- `git tag`：列出所有tag

- `git tag [tag]`：在当前的commit新建一个tag

  ```shell
  # 查看分支
  $ git branch
    dev
  * master
  # 新建标签
  $ git tag v1.0
  # 查看标签
  $ git tag
  v1.0
  # 查看日志
  $ git log --pretty=oneline --abbrev-commit
  3c7ed8d (HEAD -> master, tag: v1.0) merged bug fix 101
  0c3b23e bug fix
  12e98f0 merge with no-ff
  18d1024 add merge
  46cb0c9 conflict fix
  2a96c7e & simple
  a1be216 AND simple
  ea7ef7d branch test
  ffb8573 (origin/master) git changes
  e95e52b understand how stage works
  5b382a6 append GPL
  df126b3 modify readme.txt
  da1bff0 wrote a readme file
  ```

- `git tag [tag] [commit id]`：新建一个tag在指定commit

- `git show <tagname>`：查看标签信息

  ```shell
  # 对add merge指定标签
  $ git tag v0.9 18d1024
  # 查看标签
  $ git log --pretty=oneline --abbrev-commit
  3c7ed8d (HEAD -> master, tag: v1.0) merged bug fix 101
  0c3b23e bug fix
  12e98f0 merge with no-ff
  18d1024 (tag: v0.9) add merge
  46cb0c9 conflict fix
  2a96c7e & simple
  a1be216 AND simple
  ea7ef7d branch test
  ffb8573 (origin/master) git changes
  e95e52b understand how stage works
  5b382a6 append GPL
  df126b3 modify readme.txt
  da1bff0 wrote a readme file
  # 查看标签信息
  $ git show v0.9
  commit 18d10242e4c44358e60eaee57e626d2fa07d7fb8 (tag: v0.9)
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 22:11:00 2020 +0800
  
      add merge
  
  diff --git a/readme.txt b/readme.txt
  index 0ce4786..f6e6325 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -5,3 +5,4 @@ Git has a mutable index called stage.
   Git tracks changes.
   Creating a new branch is quick.
   Creating a new branch is quick AND simple.
  +Switched to a new branch 'dev'
  ```

- `git tag -a [tag] -m  "" [commit id]`：创建带有说明的标签

  ```
  # 建带有说明的标签
  $ git tag -a v0.1 -m "version 0.1 released" 5b382a6
  # 查勘表标签
  $ git show v0.1
  tag v0.1
  Tagger: reanon <793584285@qq.com>
  Date:   Sat Oct 3 15:49:45 2020 +0800
  
  version 0.1 released
  ...
  +Git is free software under the GPL.
  ```

- `git tag -d [tag]`：除本地tag

  ```shell
  $ git tag -d v0.1
  Deleted tag 'v0.1' (was 7da3015)
  ```

- `git push origin <tagname>`：推送某个标签到远程

- `git push origin --tags`：一次性推送全部尚未推送的本地标签到远程

  ```shell
  # 如果要推送某个标签到远程
  $ git push origin v1.0
  Enumerating objects: 9, done.
  Counting objects: 100% (9/9), done.
  Delta compression using up to 8 threads
  Compressing objects: 100% (5/5), done.
  Writing objects: 100% (5/5), 577 bytes | 577.00 KiB/s, done.
  Total 5 (delta 2), reused 0 (delta 0), pack-reused 0
  remote: Resolving deltas: 100% (2/2), completed with 1 local object.
  To github.com:Reanon/learngit.git
   * [new tag]         v1.0 -> v1.0
  # 一次性推送全部尚未推送到远程的本地标签
  $ git push origin --tags
  Total 0 (delta 0), reused 0 (delta 0), pack-reused 0
  To github.com:Reanon/learngit.git
   * [new tag]         v0.9 -> v0.9
  
  ```

- `git push origin :refs/tags/[tagName]`：删除远程tag

  ```shell
  # 要删除远程标签就麻烦一点，先从本地删除
  $ git tag -d v0.9
  Deleted tag 'v0.9' (was 18d1024)
  # 从远程删除。删除命令也是push，但是格式如下
  $ git push origin :refs/tags/v0.9
  To github.com:Reanon/learngit.git
   - [deleted]         v0.9
  ```

#### git push

- `git push [remote] [tag]`：提交指定tag
- `git push [remote] --tags`：提交所有tag

### 变基

[多主题分支变基](https://zhuanlan.zhihu.com/p/26493245)

#### git rebase

- `git rebase --onto [变基目标分支] [变基过渡分支] [变基主题分支]`：取出`变基主题分支`上进行的所有提交对象，指明`变基过渡分支`，以补丁（patches）形式在`变基目标分支`上重新应用，创建新提交对象，然后将分支指针移动到最后一个新创建的提交对象。
  - ![image-20201003151423255](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201003151430.png)
  - `git rebase --onto master issuei issue2`：执行变基；在master上复制了issue2分支的所有提交对象，此处所谓复制，是在主线创建新提交对象，而其提交内容及备注复制自issue2分支的提交对象；
  - ![image-20201003151939279](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201003151939.png)
  - 变基，需要执行合并：`git merege issue2`



- `git rebase [变基目标分支] [变基主题分支]`： 可以直接将`变基主题分支` （即本例中的 `issue1`）变基到`变基目标分支`（即 `master`）上
  - ![image-20201003152921079](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201003152921.png)
  - 变基完，快进合并主分支 `master` ：
    - `git checkout master` 
    - `git merge issue1`
  - 删除分支：`git branch -d issue1`

### 查看信息

#### git status

- `git status`：显示有变更的文件

#### git log 

- `git log`：显示当前分支的版本提交历史。

  ```
  $ git log
  commit 5b382a637edccc19981787bd834cadc7cf8b85de (HEAD -> master)
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:25:02 2020 +0800
  
      append GPL
  
  commit df126b3d1e74275f7f3e1f4d038ad90735808d59
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:23:11 2020 +0800
  
      modify readme.txt
  
  commit da1bff0dd06ff37f82a204e87a677d65fd17a63c
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:15:00 2020 +0800
  
      wrote a readme file
  ```

  

- `git log --pretty --oneline`：每条提交只显示一行。

  - commit id：`5b382a63...`

  ```shell
  $ git log --pretty=oneline
  5b382a637edccc19981787bd834cadc7cf8b85de (HEAD -> master) append GPL
  df126b3d1e74275f7f3e1f4d038ad90735808d59 modify readme.txt
  da1bff0dd06ff37f82a204e87a677d65fd17a63c wrote a readme file
  
  # 回退到上一个版本
  $ git reset --hard HEAD^
  HEAD is now at df126b3 modify readme.txt
  
  # 查看现在的日志内容，发现果然第三条日志
  $ git log
  commit df126b3d1e74275f7f3e1f4d038ad90735808d59 (HEAD -> master)
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:23:11 2020 +0800
  
      modify readme.txt
  
  commit da1bff0dd06ff37f82a204e87a677d65fd17a63c
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:15:00 2020 +0800
  
      wrote a readme file
  # 查看文件确实回到第二个版本
  $ cat readme.txt
  
  Git is a version control systeam.
  Git is free software.
  
  # 再次回到原来的版本
  $ git reset --hard 5b382a
  HEAD is now at 5b382a6 append GPL
  
  # 查看当前的日志
  $ git log
  commit 5b382a637edccc19981787bd834cadc7cf8b85de (HEAD -> master)
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:25:02 2020 +0800
  
      append GPL
  
  commit df126b3d1e74275f7f3e1f4d038ad90735808d59
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:23:11 2020 +0800
  
      modify readme.txt
  
  commit da1bff0dd06ff37f82a204e87a677d65fd17a63c
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 16:15:00 2020 +0800
  
      wrote a readme file
  ```

- `git log --graph`：可以看到分支合并图

- git log --graph --pretty=oneline --abbrev-commit：显示地更加紧凑

  ```shell
  $ git log --graph
  *   commit 46cb0c9fd2b4efeb3d08e26409c51887d9737219 (HEAD -> master)
  |\  Merge: 2a96c7e a1be216
  | | Author: reanon <793584285@qq.com>
  | | Date:   Fri Oct 2 21:56:28 2020 +0800
  | |
  | |     conflict fix
  | |
  | * commit a1be216803645243f53ec0ff919e17193d13f8f6 (feature1)
  | | Author: reanon <793584285@qq.com>
  | | Date:   Fri Oct 2 21:49:26 2020 +0800
  | |
  | |     AND simple
  | |
  * | commit 2a96c7e212d8fc1288e848f095700c0d4e2fd545
  |/  Author: reanon <793584285@qq.com>
  |   Date:   Fri Oct 2 21:50:26 2020 +0800
  |
  |       & simple
  |
  ...
  
        wrote a readme file
     
  # 显示地更加紧凑
  $ git log --graph --pretty=oneline --abbrev-commit
  *   46cb0c9 (HEAD -> master) conflict fix
  |\
  | * a1be216 (feature1) AND simple
  * | 2a96c7e & simple
  |/
  * ea7ef7d branch test
  * ffb8573 (origin/master) git changes
  * e95e52b understand how stage works
  * 5b382a6 append GPL
  * df126b3 modify readme.txt
  * da1bff0 wrote a readme file
  ```

  

- `git log -5 --pretty --oneline`：显示过去5次提交

- `git log --stat`：显示commit历史，以及每次commit发生变更的文件

- `git log -s [keyword]`：搜索提交历史，根据关键词

- `git log [tag] HEAD --pretty=format:%s`：显示某个commit之后的所有变动，每个commit占据一行

- `git log [tag] HEAD --grep feature`：显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件

- `git log --follow [file]`：显示某个文件的版本历史，包括文件改名

- `git whatchanged [file]`：显示某个文件的版本历史，包括文件改名

- `git log -p [file]`：显示指定文件相关的每一次diff

- `git shortlog -sn`：显示所有提交过的用户，按提交次数排序

#### git blame

- `git blame [file]`：显示指定文件是什么人在什么时间修改过

#### git diff

顾名思义就是查看difference，显示的格式正是Unix通用的diff格式。

- `git diff`：显示工作区和暂存区的差异；

  ```
  # 查看工作区和暂存区的区别
  $ git diff HEAD
  diff --git a/readme.txt b/readme.txt
  index 8bbf7de..9dd56e7 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -2,4 +2,4 @@
   Git is a version control systeam.
   Git is free software under the GPL.
   Git has a mutable index called stage.
  -Git tracks changes.
  +Git tracks changes of files.
  ```

- `git diff HEAD -- [readme.txt]`：查看工作区和版本库里面最新版本的区别

  ```shell
  # 查看工作区和版本库里面最新版本的区别
  $ git diff HEAD -- readme.txt
  diff --git a/readme.txt b/readme.txt
  index 8bbf7de..9dd56e7 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -2,4 +2,4 @@
   Git is a version control systeam.
   Git is free software under the GPL.
   Git has a mutable index called stage.
  -Git tracks changes.
  +Git tracks changes of files.
  
  ```

  

- `git diff [file]`：可以查看[file]的修改内容

  ```shell
  $ git diff readme.txt
  warning: LF will be replaced by CRLF in readme.txt.
  The file will have its original line endings in your working directory
  diff --git a/readme.txt b/readme.txt
  index 5c742a9..22ac2f5 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -1,3 +1,3 @@
  
  -Git is a version contril systeam.
  +Git is a version control systeam.
   Git is free software.
  ```

  

- `git diff --cached [file]`：显示暂存区和上一个commit的差异

- `git diff HEAD`：显示工作区与当前分支最新commit之间的差异

- `git diff [first-branch]...[second-branch]`：显示两次提交之间的差异：

#### git show

- `git show <tagname>`：查看标签信息

  ```shell
  $ git show v0.9
  commit 18d10242e4c44358e60eaee57e626d2fa07d7fb8 (tag: v0.9)
  Author: reanon <793584285@qq.com>
  Date:   Fri Oct 2 22:11:00 2020 +0800
  
      add merge
  
  diff --git a/readme.txt b/readme.txt
  index 0ce4786..f6e6325 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -5,3 +5,4 @@ Git has a mutable index called stage.
   Git tracks changes.
   Creating a new branch is quick.
   Creating a new branch is quick AND simple.
  +Switched to a new branch 'dev'
  ```

- `git show [commit]`：显示某次提交的元数据和内容变化

- `git show --name-only [commit]`：显示某次提交发生变化的文件

- `git show [commit]:[filename]`：显示某次提交时，某个文件的内容

#### git relog

- `git reflog`：查看命令历史；用来记录你的每一次命令

  - 前面的是所在分支的`commit id`
  - 然后使用`git reset --hard [commit id]`回到想去的版本号

  ```shell
  $ git reflog
  5b382a6 (HEAD -> master) HEAD@{0}: reset: moving to 5b382a
  df126b3 HEAD@{1}: reset: moving to HEAD^
  5b382a6 (HEAD -> master) HEAD@{2}: commit: append GPL
  df126b3 HEAD@{3}: commit: modify readme.txt
  da1bff0 HEAD@{4}: commit (initial): wrote a readme file
  ```

  

### 远程同步

#### git checkout

- `git checkout -b branch-name origin/branch-name`：在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致。

  ```shell
  # 克隆远程仓库
  $ git clone git@github.com:Reanon/learngit.git
  Cloning into 'learngit'...
  remote: Enumerating objects: 35, done.
  remote: Counting objects: 100% (35/35), done.
  remote: Compressing objects: 100% (21/21), done.
  remote: Total 35 (delta 11), reused 34 (delta 10), pack-reused 0
  Receiving objects: 100% (35/35), done.
  Resolving deltas: 100% (11/11), done.
  
  # 默认只拉取master
  $ git branch
  * master
  
  # 拉取远程的分支
  $ git checkout -b dev origin/dev
  Switched to a new branch 'dev'
  Branch 'dev' set up to track remote branch 'dev' from 'origin'.
  
  ```

#### git pull

- `git pull [remote] [branch]`：取回远程仓库的变化，并与本地分支合并

#### git fetch

- `git fetch origin dev`：把远程分支拉到本地
- `git fetch [remote]`：下载远程仓库的所有变动

#### * git remote

- `git remote add [origin] git@server-name:path/repo-name.git`：关联一个远程库

  - 可以给远程关联仓库指定名称：[origin]
  
  ```shell
  # 在git目录下关联一个远程库,指定名为origin
  $ git remote add origin git@github.com:Reanon/learngit.git
  
  # 第一次推送master分支的所有内容
  $ git push -u origin master
  
  # 当第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告
  The authenticity of host 'github.com (13.250.177.223)' can't be established.
  RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
  Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
  Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts.
  Enumerating objects: 16, done.
  Counting objects: 100% (16/16), done.
  Delta compression using up to 8 threads
  Compressing objects: 100% (12/12), done.
  Writing objects: 100% (16/16), 1.25 KiB | 642.00 KiB/s, done.
  Total 16 (delta 3), reused 0 (delta 0), pack-reused 0
  remote: Resolving deltas: 100% (3/3), done.
  To github.com:Reanon/learngit.git
   * [new branch]      master -> master
  Branch 'master' set up to track remote branch 'master' from 'origin'.

  ```

- `git remote`：查看远程库的信息

  ```shell
  # 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin
  $ git remote
  origin
  ```

- `git remote -v`：显示所有远程仓库更详细的信息

  ```shell
  $ git remote -v
  origin  git@github.com:Reanon/learngit.git (fetch)
  origin  git@github.com:Reanon/learngit.git (push)
  ```

- `git remote rm [origin`]：删除已有的GitHub远程库

- `git remote show [remote]`：显示某个远程仓库的信息

- `git remote add [shortname] [url]`：增加一个新的远程仓库，并命名

#### git push

- `git push -u [origin] master`：第一次推送master分支的所有内容

- `git push [remote] [branch]`：上传本地指定分支到远程仓库
  
  - 在第一次提交之后，只要有必要，就可以使用命令`git push origin master`推送最新修改
  
  ```shell
  $ git push origin dev
  Warning: Permanently added the RSA host key for IP address '13.229.188.59' to the list of known hosts.
  Enumerating objects: 21, done.
  Counting objects: 100% (21/21), done.
  Delta compression using up to 8 threads
  Compressing objects: 100% (19/19), done.
  Writing objects: 100% (19/19), 1.74 KiB | 1.74 MiB/s, done.
  Total 19 (delta 7), reused 0 (delta 0), pack-reused 0
  remote: Resolving deltas: 100% (7/7), done.
  remote:
  remote: Create a pull request for 'dev' on GitHub by visiting:
  remote:      https://github.com/Reanon/learngit/pull/new/dev
  remote:
  To github.com:Reanon/learngit.git
   * [new branch]      dev -> dev
  ```
  
- `git push [remote] --force`：强行推送当前分支到远程仓库，即使有冲突

- `git push [remote] --all`：推送所有分支到远程仓库

- `git push origin --delete [branch-name]`：删除远程分支

### 撤销

#### git checkout

- `git checkout -- [file]`：把`file`文件在工作区的修改全部撤销

  - `git checkout -- [file]`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令

  ```shell
  # 在文件中新增了一些内容
  $ git diff
  diff --git a/readme.txt b/readme.txt
  index 8bbf7de..c3c78ee 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -2,4 +2,5 @@
   Git is a version control systeam.
   Git is free software under the GPL.
   Git has a mutable index called stage.
  -Git tracks changes.
  +Git tracks changes of files.
  +My stupid boss still prefers SVN.
  
  # 把readme.txt文件在工作区的修改全部撤销，这里有两种情况
  ## 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
  ## 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
  $ git checkout -- readme.txt
  
  # 再次查看信息，发现没有不同
  $ git diff
  
  ```

  

- `git checkout  [file]`：恢复暂存区的指定文件到工作区

  - 也可以恢复删除的文件

  ```shell 
  # 新建文件
  $ touch test.txt
  # 添加文件
  $ git add test.txt
  # 删除文件
  $ rm test.txt
  # 查看状态
  $ git status
  On branch master
  Changes to be committed:
    (use "git restore --staged <file>..." to unstage)
          new file:   test.txt
  
  Changes not staged for commit:
    (use "git add/rm <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
          deleted:    test.txt
  
  # 显示
  $ ls
  LICENSE  readme.txt
  # 从暂存区恢复删除的文件
  $ git checkout -- test.txt
  
  ```

- `git checkout [commit] [file]`：恢复某个commit的指定文件到暂存区和工作区

- `git checkout .`：恢复暂存区的所有文件到工作区

#### git reset

- `git reset HEAD [file]`可以把暂存区的修改撤销掉（unstage），重新放回工作区

  ```shell
  # 查看当前暂存区和版本库的区别
  $ git diff HEAD -- readme.txt
  diff --git a/readme.txt b/readme.txt
  index 8bbf7de..cbea1d3 100644
  --- a/readme.txt
  +++ b/readme.txt
  @@ -3,3 +3,4 @@ Git is a version control systeam.
   Git is free software under the GPL.
   Git has a mutable index called stage.
   Git tracks changes.
  +My stupid boss still prefers SVN.
  # 把暂存区的修改撤销掉（unstage），重新放回工作区
  $ git reset HEAD readme.txt
  Unstaged changes after reset:
  M       readme.txt
  # 查看一下，暂存区干净，工作区有修改
  $ git status
  On branch master
  Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
          modified:   readme.txt
  # 丢弃工作区修改
  $ git checkout -- readme.txt
  
  $ git status
  On branch master
  nothing to commit, working tree clean
  
  ```

- `git reset --hard HEAD^`回退上一个版本
  
  - `HEAD`指向的版本就是当前版本
  - `HEAD^`就是上一个版本
  - `HEAD^^`就是上上一个版本
  - `HEAD~100`往上100个版本
  
  ```shell
  # 查看日志
  $ git log --pretty=oneline
  5b382a637edccc19981787bd834cadc7cf8b85de (HEAD -> master) append GPL
  df126b3d1e74275f7f3e1f4d038ad90735808d59 modify readme.txt
  da1bff0dd06ff37f82a204e87a677d65fd17a63c wrote a readme file
  
  # 回到上一个版本
  $ git reset --hard HEAD^
  HEAD is now at df126b3 modify readme.txt
  
  # 查看历史命令
  $ git reflog
  5b382a6 (HEAD -> master) HEAD@{0}: reset: moving to 5b382a
  df126b3 HEAD@{1}: reset: moving to HEAD^
  5b382a6 (HEAD -> master) HEAD@{2}: commit: append GPL
  df126b3 HEAD@{3}: commit: modify readme.txt
  da1bff0 HEAD@{4}: commit (initial): wrote a readme file
  
  # 回到指定版本
  $ git reset --hard 5b382a
  HEAD is now at 5b382a6 append GPL
  ```
  
- `git reset --hard`：重置暂存区与工作区，与上一次commit保持一致

- `git reset --hard [commit]`：重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致

- `git reset [file]`：重置暂存区的指定文件，与上一次commit保持一致，但工作区不变

- git reset [ commit]：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变

- git reset --keep [ commit]：重置当前HEAD为指定commit，但保持暂存区和工作区不变

- git revert [commit]：新建一个commit，用来撤销指定commit；后者的所有变化都将被前者抵消，并且应用到当前分支

#### git stash

- `git stash`：暂时将未提交的变化移除，稍后再移入

  ```shell
  # 工作进行到一半
  $ git status
  On branch master
  Your branch is ahead of 'origin/master' by 6 commits.
    (use "git push" to publish your local commits)
  
  Changes to be committed:
    (use "git restore --staged <file>..." to unstage)
          new file:   hello.txt
  
  Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
          modified:   readme.txt
  
  # 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
  $ git stash
  Saved working directory and index state WIP on master: 12e98f0 merge with no-ff
  
  # 当前工作区是干净的了
  $ git status
  On branch master
  Your branch is ahead of 'origin/master' by 6 commits.
    (use "git push" to publish your local commits)
  
  nothing to commit, working tree clean
  # 开始修复bug
  $ git checkout master
  Switched to branch 'master'
  Your branch is ahead of 'origin/master' by 6 commits.
    (use "git push" to publish your local commits)
  # 创建并切换到bug修复的分支
  $ git checkout -b issue-101
  Switched to a new branch 'issue-101'
  # 开始修复
  $ git add readme.txt 
  $ git commit -m "fix bug 101"
  [issue-101 4c805e2] fix bug 101
   1 file changed, 1 insertion(+), 1 deletion(-)
   # 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支
   $ git switch master
  Switched to branch 'master'
  Your branch is ahead of 'origin/master' by 6 commits.
    (use "git push" to publish your local commits)
  # 合并bug修复分支
  $ git merge --no-ff -m "merged bug fix 101" issue-101
  Merge made by the 'recursive' strategy.
   readme.txt | 2 +-
   1 file changed, 1 insertion(+), 1 deletion(-)
   # 切换回原来的工作分支
   $ git switch dev
  Switched to branch 'dev'
  # 查看缓存的工作现场
  $ git stash list
  stash@{0}: WIP on master: 12e98f0 merge with no-ff
  ```

- `git stash pop`：恢复stash，并且删除stash内容

  ```shell
  # 恢复stash，并且删除stash内容
  $ git stash pop
  On branch dev
  Changes to be committed:
    (use "git restore --staged <file>..." to unstage)
          new file:   hello.txt
  
  Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
          modified:   readme.txt
  
  Dropped refs/stash@{0} (d3ce847867cb893c8cd6eb895b8bbf7ea856b4d3)
  ```

- `git stash apply stash@{[id]}`：恢复stash内容，但是恢复后，stash内容并不删除

- `git stash drop stash@{[id]}`：删除stash内容

  ```shell
  # 查看stash
  $ git stash list
  stash@{0}: WIP on master: 12e98f0 merge with no-ff
  # 删除stash
  $ git stash drop stash@{0}
  Dropped stash@{0} (1916d3f801f997bd10c05cf3ffff53963c57d7ae)
  # 再次查看stash
  $ git stash list
  ```





## Git项目搭建

### 创建工作目录与常用指令

工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。

日常使用只要记住下图6个命令：

![image-20200929154934216](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929154934.png)

### 本地仓库搭建

创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。

1. 创建全新的仓库，需要用GIT管理的项目的根目录执行：`git init`
2. 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。

```shell
# 在当前目录新建一个Git代码库
$ git init
Initialized empty Git repository in D:/Desktop/gitproject/.git/

$ ls -a -h
./  ../  .git/

```

### 克隆远程仓库

- 克隆远程仓库：`git clone [url]` 

1. 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地

   ```shell
   # 克隆一个项目和它的整个代码历史(版本信息)
   $ git clone https://gitee.com/kuangstudy/openclass.git
   Cloning into 'openclass'...
   remote: Enumerating objects: 272, done.
   remote: Counting objects: 100% (272/272), done.
   remote: Compressing objects: 100% (182/182), done.
   remote: Total 272 (delta 98), reused 119 (delta 68), pack-reused 0
   Receiving objects: 100% (272/272), 13.41 MiB | 2.72 MiB/s, done.
   Resolving deltas: 100% (98/98), done.
   
   $ ls
   openclass/
   ```
   

### 关联远程仓库

本地库就可以同时与多个远程库互相同步

![image-20201003162046961](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201003162047.png)

- `git remote add [origin] [url] `本地库上使用命令把它和Gitee的远程库关联

- `git remote rm origin`可以删除已有的远程仓库

  ```shell
  $ git remote -v
  origin  https://gitee.com/Reanon/specsocket.git (fetch)
  origin  https://gitee.com/Reanon/specsocket.git (push)
  # 删除远程仓库
  git remote rm origin
  
  # 先关联GitHub的远程库
  $ git remote add github git@github.com:Reanon/SPECsocket.git
  # 再关联Gitee的远程库（注意路径中需要填写正确的用户名）
  $ git remote add gitee git@gitee.com:Reanon/specsocket.git
  
  # 查看远程库信息，可以看到两个远程库
  $ git remote -v
  gitee   git@gitee.com:Reanon/specsocket.git (fetch)
  gitee   git@gitee.com:Reanon/specsocket.git (push)
  github  git@github.com:Reanon/SPECsocket.git (fetch)
  github  git@github.com:Reanon/SPECsocket.git (push)
  # 如果要推送到GitHub，使用命令：
  $ git push github master
  # 如果要推送到Gitee，使用命令：
  $ git push gitee master
  # 拉取远程仓库的分支
  $ git pull [gitee] [dev]
  ```

## Git项目规范

[git commit 规范指南](https://segmentfault.com/a/1190000009048911)

### 分支命名

#### master 分支

master 为主分支，也是用于部署生产环境的分支，确保master分支稳定性

- master 分支一般由develop以及hotfix分支合并
- 任何时间都不能直接修改代码

#### develop 分支

develop 为开发分支，始终保持最新完成以及bug修复后的代码

- 一般开发的新功能时，feature分支都是基于develop分支下创建的

#### feature 分支

开发新功能时，以develop为基础创建feature分支

- 分支命名: feature/开头的为特性分支
- 命名规则: feature/user_module、 feature/cart_module

#### release分支

release 为预上线分支，发布提测阶段，会release分支代码为基准提测

- 当有一组feature开发完成，首先会合并到develop分支，进入提测时，会创建release分支。
- 如果测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。
- 当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。

#### hotfix 分支

线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支

- 分支命名: hotfix/ 开头的为修复分支；它的命名规则与 feature 分支类似

### 常见任务

#### 增加新功能

```shell
# 从dev建立特性分支
(dev)$: git checkout -b feature/xxx
# 开发
(feature/xxx)$: blabla                         
(feature/xxx)$: git add xxx
(feature/xxx)$: git commit -m 'commit comment'

# 把特性分支合并到dev
(dev)$: git merge feature/xxx --no-ff          
```

#### 修复紧急bug

```shell
# 从master建立hotfix分支
(master)$: git checkout -b hotfix/xxx

# 开发
(hotfix/xxx)$: blabla                         
(hotfix/xxx)$: git add xxx
(hotfix/xxx)$: git commit -m 'commit comment'

# 把hotfix分支合并到master，并上线到生产环境
(master)$: git merge hotfix/xxx --no-ff

# 把hotfix分支合并到dev，同步代码
(dev)$: git merge hotfix/xxx --no-ff          
```

#### 测试环境代码

```shell
# 把dev分支合并到release，然后在测试环境拉取并测试
(release)$: git merge dev --no-ff             
```

#### 生产环境上线

```shell
# 把release测试好的代码合并到master，运维人员操作
(master)$: git merge release --no-ff
# 给版本命名，打Tag
(master)$: git tag -a v0.1 -m '部署包版本名'  
```

### 日志规范

编写良好的Commit messages可以达到3个重要的目的：

- 加快review的流程
- 帮助我们编写良好的版本发布日志
- 让之后的维护者了解代码里出现特定变化和feature被添加的原因

目前，社区有多种 Commit message 的写法规范。来自Angular 规范是目前使用最广的写法，比较合理和系统化。

#### Commit messages的基本语法

当前业界应用的比较广泛的是 [Angular Git Commit Guidelines](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md)，具体格式如下：

- header 是必需的，body 和 footer 可以省略。
- 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。

```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

##### Header

Header部分只有一行，包括三个字段：`type`（必需）、`scope`（可选）和`subject`（必需）

###### type

用于说明 commit 的类别，只允许使用下面7个标识：

- feat：新功能（feature）
- fix：修补bug
- docs：文档（documentation）
- style： 格式（不影响代码运行的变动）
- refactor：重构（即不是新增功能，也不是修改bug的代码变动）
- test：增加测试
- chore：构建过程或辅助工具的变动

如果type为`feat`和`fix`，则该 commit 将肯定出现在 Change log 之中。其他情况（`docs`、`chore`、`style`、`refactor`、`test`）由你决定，要不要放入 Change log，建议是不要。

###### scope

scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。

- 例如在`Angular`，可以是`$location`, `$browser`, `$compile`, `$rootScope`, `ngHref`, `ngClick`, `ngView`等。

如果你的修改影响了不止一个`scope`，你可以使用`*`代替。

###### subject

`subject`是 commit 目的的简短描述，不超过50个字符。其他注意事项：

- 以动词开头，使用第一人称现在时，比如change，而不是changed或changes
- 第一个字母小写
- 结尾不加句号（.）

body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，如需换行，则使用  `|`

footer：描述下与之关联的 issue 或 break change

##### Body

Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。

```shell
More detailed explanatory text, if necessary.  Wrap it to 
about 72 characters or so. 

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Use a hanging indent
```

有两个注意点:

- 使用第一人称现在时，比如使用change而不是changed或changes。
- 永远别忘了第2行是空行
- 应该说明代码变动的动机，以及与以前行为的对比。

##### Footer

Footer 部分只用于以下两种情况：



#### Commit messages格式要求

```shell
# 标题行：50个字符以内，描述主要变更内容

# 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:

# * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等
# * 他如何解决这个问题? 具体描述解决问题的步骤
# * 是否存在副作用、风险?

# 如果需要的化可以添加一个链接到issue地址或者其它文档
```



## 码云

在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器。

### 注册登录

完善个人信息

### 设置本机绑定SSH公钥

[官方教程](https://gitee.com/help/articles/4191#article-header0)，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)

- 在本地生成公钥：`ssh-keygen -t rsa`
- 公钥：`id_rsa.pub`
- 私钥：`id_rsa.pub`

```shell
# 生成公钥
ssh-keygen

# Windows端：在 C:\Users\reanon\.ssh 目录

# Linux端在：/root/.ssh
id_rsa  id_rsa.pub  known_hosts
```

![image-20200929164736379](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929164736.png)

### 添加公钥public key 

将生成的公钥添加到码云账户中即可

- 将生成`id_rsa.pub`的代码黏贴进gitee的公钥栏里
- ![image-20200929165222476](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929165222.png)

### 创建仓库

使用码云创建一个自己的仓库

![image-20200929165542911](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929165542.png)

许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，...  限制！

### 克隆到本地

从远程克隆

```shell 
# 从远程克隆
$ git clone https://gitee.com/Reanon/gitstudy.git
Cloning into 'gitstudy'...
remote: Enumerating objects: 6, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (6/6), 13.23 KiB | 483.00 KiB/s, done.
# 查看是否克隆成功
$ ls
gitstudy/
# 查看下载的文件的内容
$ ls gitstudy/
LICENSE  README.en.md  README.md

```

克隆成功

![image-20200929170211544](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929170211.png)

## GitHub

### 创建SSH Key

```shell
$ ssh-keygen -t rsa -C "youremail@example.com"
```

私钥和公钥在用户主目录中：

- 私钥：`id_rsa` 
- 公钥： `id_rsa.pub`

```shell
# 用户主目录中
$ cd /c/Users/Reanon/.ssh

$ ls
id_rsa  id_rsa.pub  known_hosts
```

在setting->SSH and GPG keys->key中输入公钥：

![image-20201002203752925](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201002203800.png)

成功添加

![image-20201002204037319](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201002204037.png)

## Pycharm中集成

### 本地同步

1. 新建远程仓库
2. 将远程仓库同步到某个文件中
3. 将该文件中生成`.git`隐藏文件复制到项目中

### 一些技巧

1、[linux服务器git pull/push时提示输入账号密码之免除设置](https://blog.csdn.net/qq_15245487/article/details/105213844?utm_medium=distribute.pc_relevant.none-task-blog-title-5&spm=1001.2101.3001.4242)

- 在终端的根目录`/`下执行：`git config --global credential.helper store`
- 之后cd到项目目录，执行git pull命令，会提示输入账号密码。输完这一次以后就不再需要，并且会在根目录生成一个.git-credentials文件
- 之后pull/push代码都不再需要输入账号密码了

## IDEA集成Git

.gitignore

```javascript
**/target/
**/.settings/
**/.classpath
**/.checkstyle
**/.project
**/.*.swp
*.DS_Store*
**/test-output/
**/.metadata/
.recommenders/
**/.springBeans
**/.factorypath
.idea/
*.iml
/bin/
**/bin/
**/.mvn/
.gitignore
```



### 新建项目，绑定Git



### 修改文件，使用IDEA操作Git

- 添加到暂存区
- commit 提交
- push到远程仓库

### 提交测试

单个人的操作

## Git分支

分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！

![image-20200929172943176](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929172943.png)

一般的分支结构

![image-20200929173206642](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929173206.png)



如果同一个文件在合并分支时都被修改了则会引起冲突：

- 解决的办法是我们可以修改冲突文件后重新提交！
- 选择要保留他的代码还是你的代码！

master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。



