Linux 

## Linux 简介

Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。

### Linux 发行版

Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等；其中Kail linux更多用作安全渗透使用。

![常用Linux发行版操作系统](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201011100748.jpeg)

### Linux 应用领域

今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用：

- LAMP（Linux + Apache + MySQL + PHP）
-  LNMP（Linux + Nginx+ MySQL + PHP）组合。

### Linux 环境搭建

#### 云服务器安装

1. [阿里云购买链接](https://www.aliyun.com/minisite/goods?userCode=0phtycgr)

2. 获取服务器的ip地址，重置服务器密码，就可以远程登录了

3. 实例-> 添加安全组-> 授权安全组

   ![image-20201011102932957](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201011102933.png)

4. 使用Xshell

   - Linux启用SSHD服务(会监听22号端口）：`service sshd start` 

#### 虚拟机安装

#### 双系统安装 Centos 8

##### 制作U盘镜像

在[Centos](https://www.centos.org/download/)官网下载镜像，选择ISO的x86_64

![1](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925134236.png)

在其他镜像中选择其他的镜像来源

![T72SSQ}9YIY6IUBSWH493IT](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925134242.png)

选择最大的那个安装包下载

![w](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925134329.png)

安装[rufus](https://rufus.ie/)，然后将下载好的镜像安装到U盘中，大概会执行十分钟左右

![2](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925135346.png)

##### 格式化Windows的硬盘

在Win + R 中输入`diskmgmt.msc`打开磁盘管理，选择一个卷点击“删除卷”

![45](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925135454.png)

win10进入bios模式，操作方法：

1：点击“开始”菜单，再点“系统设置”之后点“更新和安全”。

2：弹出设置对话框，点击“恢复”，再点击“高级启动”项下的“立即重启”按钮。

3：计算机将重启，进入高级维修模式，点击“疑难解答”项，再点击“高级选项”。

4：在"高级选项“中，点击”UEFI固件设置“项，确定后，计算机将再次重启，最后进入bios。

##### 进入BIOS

![biso](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925135652.jpg)

将U盘启动放到最前，F10保存并重启。

![bios](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200925135657.jpg)

进入安装系统中，自定义硬盘，首先点击自动分配，然后自己手动调一调（我也不是很会）

- /：给了150G
- swap：16G 
- /boot：1G
- /home：500G（剩下全部）

## Linux系统

linux 没有输出就代表是成功

### 开机登录

开机会启动许多程序。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。

开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！

最高权限账户为 root，可以操作一切；一般来说，用户的登录方式有三种：

- 命令行登录
- ssh登录
- 图形界面登录

#### ssh 登录

如果希望安装好XShell就可以远程访问Limux系统的话，需要有一个前提，就是Linux启用了SSHD服务，该服务会监听22号端口。

```shell
# 开启sshd
[root@reanon ~]# service sshd start
Redirecting to /bin/systemctl start sshd.service
# 查看sshd 状态
[root@reanon ~]# service sshd status
```

查看sshd 状态

![image-20201013171921328](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201013171921.png)

### 关机

在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。不管是重启系统还是关闭系统，首先要运行`sync` 命令，把内存中的数据写到磁盘中。

- 数据由内存同步到硬盘：`sync`
- 关机指令为：`shutdown` 
- 重启命令：`reboot`

```shell
# 将数据由内存同步到硬盘中。
sync

shutdown      # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机： 

shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机

shutdown –h now # 立马关机

shutdown –h 20:25 # 系统会在今天20:25关机

shutdown –h +10 # 十分钟后关机

shutdown –r now # 系统立马重启

shutdown –r +10 # 系统十分钟后重启

reboot # 就是重启，等同于 shutdown –r now

halt # 关闭系统，等同于shutdown –h now 和 poweroff
```

### 系统目录结构

一切文件皆目录，所有节点都挂载在根目录`/`下

![img](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201011105511.jpeg)

以下是对这些目录的解释：

#### 系统启动

- **/boot：** 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。
- ==**/etc：**  Etcetera(等等)，这个目录用来存放所有的系统管理所需要的配置文件和子目录。==
  - /etc/sysconfig/network-scripts/：网络配置目录
  - /etc/passwd 文件：用户（user）的配置文件，记录用户的各种信息；每行的含义：`用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell`
  - /etc/shadow 文件：口令的配置文件；每行的含义：`登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志`
  - /etc/group 文件：组(group)的配置文件，记录Linux包含的组的信息；每行含义：`组名:口令:组标识号:组内用户列表`
  - inittab：运行级别配置
- **/lib**：Library(库) ，这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。
- **/sys**：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。

#### 指令集合

- **/bin**：Binary, 这个目录存放着最经常使用的命令。
- **/sbin**：super user binaries（超级用户的二进制文件），这里存放的是系统管理员使用的系统管理程序。

#### 外部文件管理

- **/dev ：** Devices(设备), 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
- **/media**：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。
- **/mnt**：mount(安装)，系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。

#### 临时文件

- ==**/tmp**：temporary（临时），这个目录是用来存放一些临时文件的。==
- **/run**：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。
- **/lost+found**：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

#### 账户

- **/root**：该目录为系统管理员，也称作超级权限者的用户主目录。
- ==**/home**：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。==
- ==**/usr**：unix shared resources(共享资源) ，用于共享的系统资源；用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。==
- **/usr/bin：** 系统用户使用的应用程序。
- **/usr/sbin：** 超级用户使用的比较高级的管理程序和系统守护程序。
- **/usr/src：** 内核源代码默认的放置目录。
- **/usr/local**：给主机额外安装软件的目录。一般是通过编译源码方式安装的程序。

#### 运行过程中要用

- **/var**：variable(变量)，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。
- **/proc**：Processes(进程)，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。

#### 拓展

- ==**/opt**：optional(可选) ，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。==

- **/www**：存放服务器网站相关的资源，环境，网站的项目

  ![image-20201011111450549](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20201011111450.png)

- **/srv**：service，该目录存放一些服务启动之后需要提取的数据。

在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。

- `/etc`： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。my.conf
- `/bin`、`/sbin`、 `/usr/bin`、 `/usr/sbin`：这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。
  - /bin、 /usr/bin 是给系统用户使用的指令（除root外的通用户）
  - /sbin、/usr/sbin 则是给 root 使用的指令。
- `/var`： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 `/var/log` 目录下，另外 mail 的预设放置也是在这里。

### 运行级别

常用运行级别是3和5 ，要修改默认的运行级别可改文件 `/etc/inittab`的id:5:initdefault:这一行中的数字。运行级别说明：

- 0 ：关机
- 1 ：单用户【找回丢失密码】
- 2：多用户状态没有网络服务
- ==3：多用户状态有网络服务==
- 4：系统未使用保留给用户
- ==5：图形界面==
- 6：系统重启

#### init 切换运行级别

init number

- number：也就是数字 0-6
- init 0 ：关机
- init 3：进入命令行模式

进入单用户模式找回密码



## 常用基本命令

[Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)：基本上的命令都有的； [Linux 常用命令全拼](https://www.runoob.com/w3cnote/linux-command-full-fight.html)

### 目录管理

绝对路径和相对路径

- 绝对路径：路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。
- 相对路径：路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man

处理目录的常用命令：

- ls: 列出目录
- cd：切换目录
- pwd：显示目前的目录
- mkdir：创建一个新的目录
- rmdir：删除一个空的目录
- cp: 复制文件或目录
- rm: 移除文件或目录
- mv: 移动文件与目录，或修改文件与目录的名称

#### ls 列出目录

在Linux系统当中， ls 命令可能是最常被运行的。

[ls](https://www.runoob.com/linux/linux-comm-ls.html)：list files [v. 连接，连结，使连锁]

- 命令用于显示指定工作目录下之内容

语法格式：`ls [-aAdfFhilnrRSt] 目录名称`

- -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来
- -l ：长数据串列出，包含文件的属性与权限等等数据；

```shell
[root@reanon home]# ls -l
total 16
drwxr-xr-x 2 root root 4096 Sep 28 10:17 dockerfile
...
[root@reanon home]# ls -a
.  ..  dockerfile  mysql  mythril  reanon  test.java

[root@reanon home]# ls -al
total 24
drwxr-xr-x.  6 root root 4096 Sep 28 16:00 .
...
```

#### cd 切换目录

cd：change directory

- 用于切换当前工作目录
- `~` 也表示为 home 目录 的意思
- `.` 则是表示目前所在的目录
- `..`则表示目前目录位置的上一层目录

语法格式：`cd [dirName]`

- `cd ~`：切换到 home 目录
- `cd ../..`：跳到目前目录的上上两层

```
[root@reanon reanon]# cd ../..
[root@reanon /]# pwd
/

[root@reanon /]# cd ~ 
[root@reanon ~]# pwd
/root
```

#### pwd 显示目录

pwd：print work directory

- 显示工作目录；执行 pwd 指令可立刻得知目前所在的工作目录的绝对路径名称

语法格式：`pwd [--help][--version]`

- --help 在线帮助
- --version 显示版本信息

#### mkdir 创建目录

mkdir：make directory

- 创建目录

语法格式：`mkdir [-mp] dirName`

- -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来
- -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色

```
# 创建目录
[root@reanon reanon]# mkdir test

# 加了这个 -p 的选项，递归创建多层文件夹 
[root@reanon reanon]# mkdir -p test/test/test

```



#### rmdir 删除目录

rmdir：remove directory

- 删除空的目录
- 提示：如果需要删除非空目录：`rm -rf [要删除的目录]`

语法格式：`rmdir [-p] dirName`

- -p：连同上一级『空的』目录也一起删除。

```
[root@reanon reanon]# mkdir -p test/test/test

[root@reanon reanon]# rmdir test/test/test/
[root@reanon reanon]# ls
build test
# 可以直接删除 test/test/test/中最底层的文件夹
[root@reanon reanon]# rmdir -p  test/test/test/
# 利用 -p 这个选项，立刻就可以将 test/test/依次删除
[root@reanon reanon]# rmdir -p  test/test/
[root@reanon reanon]# ls
build
```



#### touch 创建文件

touch：

- 用于修改文件或者目录的时间属性，包括存取时间和更改时间。
- 若文件不存在，系统会建立一个新的文件

语法格式：`touch [文件名称]`

- 

#### cp 复制

cp：copy file

- 复制文件或目录

语法格式：`cp [-adfilprsu] source destination`  或者`cp [options] source1 source2 source3 ... directory`

- -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)
- -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
- -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
- -r(recursive)：递归持续复制，用於目录的复制行为；(常用)
- -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
- -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
- -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。
- -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
- -u：若 destination 比 source 旧才升级 destination ！

强制覆盖不提示的方法：`\cp ...`

```shell
# 创建空白目录
[root@reanon reanon]# mkdir test
# 创建空白文件
[root@reanon reanon]# touch test.txt
# 将/reanon/aaa.txt 拷贝到/reanon/test 目录下
[root@reanon reanon]# cp test.txt test

# 如果文件重复，就选则覆盖（y）或者放弃（n)
[root@reanon reanon]# cp test.txt test
cp: overwrite ‘test/test.txt’? y

# 递归复制整个文件夹:将 /home/test整个目录  拷贝到/home/zwj目录
[root@reanon home]# cp -r  test/ zwj/
[root@reanon home]# ls zwj/
test   
# 强制覆盖不提醒
[root@reanon home]# \cp -r  test/ zwj/
```

#### rm 移除

rm：remove

- 删除一个文件或者目录

语法格式：`rm [-fir] name...`

- -r：递归删除啊！最常用在目录的删除了。
- -f：就是 force 的意思，强制删除不提示
- -i：互动模式，在删除前会询问使用者是否动作。

常用命令

- `rm -rf name`:递归强制删除不提示

```
# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！
[root@reanon reanon]# rm -i test/test.txt 
rm: remove regular empty file ‘test/test.txt’? y
# 删库跑路：rm -rf /
```

#### mv 移动

[mv](https://www.runoob.com/linux/linux-comm-mv.html):move file

- 用来为文件或目录改名、或将文件或目录移入其它位置。

语法格式：`mv [-fiu] source destination`或者 `mv [options] source1 source2 source3 .... directory`

- -f：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
- -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖
- -u：替换更新过的文件；若目标文件已经存在，且 source 比较新，才会升级 (update)

常用命令

- 重命名：`mv oldNameFile newNameFile` 
- 移动文件：`mv /temp/movefile /targetFolder`

```
# 移动文件
[root@reanon reanon]# mv test.txt test/
[root@reanon reanon]# ls
build  test

# 重命名文件夹
[root@reanon reanon]# mv test test1
[root@reanon reanon]# ls
build  test1
```

### 基本权限

Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

在Linux中我们可以使用`ll`或者`ls –l`命令来显示一个文件的属性以及文件所属的用户和组，如：

```
[root@reanon /]# ls -l
total 68
lrwxrwxrwx.  1 root root     7 Aug 17 14:07 bin -> usr/bin
...
```

ls -l 中显示的内容如下：`-rwxrw-r--1 root root 1213 Feb 2 09:39 abc`

- 第一个字符代表文件类型：
  - [ d ]：则是目录
  - [ - ]：则是文件；
  - [ l ]：则表示为链接文档 ( link file )；
  - [ b ]：则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
  - [ c ]：则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )
- 其余字符每3个一组(rwx) 读(r) 写(w) 执行(x)；三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已
  - [ r ]：代表可读(read)
  - [ w ]：代表可写(write)
  - [ x ]：代表可执行(execute)
- 文件(硬连接数) 或 目录(子目录数)：1  
- 用户：root 
- 组：root 
- 文件大小(字节)，如果是文件夹，显示4096字节：1213 
- 最后修改日期：Feb 2 09:39 
- 文件名：abc 

![Linux 文件权限管理](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201012174848.png)

#### chmod 修改权限

chmod：Change mode

- 修改文件或者目录的权限。

##### 符号变更权限

符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限）

语法格式：`chmod [-R] [ugoa] [[+-=][rwxX]] file...` 或

- who（用户类型）

  - u(user)：文件所有者
  - g(group)：文件所有者所在组
  - o(others)：所有其他用户
  - a(all)：所用用户，相当于ugo

- operator（操作符）

  - +：为指定的用户类型增加权限

  -	-：去除指定用户类型的权限
  -	=：设置指定用户权限的设置，即将用户类型的所有权限重新设置

- permission（权限）

  - r：读，设置为可读权限
  - w：写，设置为可写权限
  - x：执行权限，设置为可执行权限
  - X：特殊执行权限，只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行
  - s：setuid/gid，当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限
  - t：粘贴位，设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位

- -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)

```shell
...
-rw-r--r-- 1 root root 0 Oct 12 17:32 test.txt
# 将文件设为所有人都可执行
[root@reanon test1]# chmod +x test.txt 
[root@reanon test1]# ll
...
-rwxr-xr-x 1 root root 0 Oct 12 17:32 test.txt

# 给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限
[root@reanon test]# chmod u=rwx,g=rx,o=rx abc
-rwxr-xr-x 1 root root   0 Oct 13 17:55 abc

# 给abc文件的所有者除去执行的权限，增加组写的权限
[root@reanon test]# chmod u-x,g+w abc
-rw-rwxr-x 1 root root   0 Oct 13 17:55 abc

# 给abc文件的所有用户添加读的权限
[root@reanon test]# chmod a+r abc
-rw-rwxr-x 1 root root   0 Oct 13 17:55 abc
# 将目前目录下的所有文件与子目录皆设为任何人可读取
[root@reanon reanon]# chmod -R a+r *
```

##### 数字变更权限

chmod命令可以使用八进制数来指定权限。文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：`r:4     w:2         x:1`

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx---] 分数则是：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others = ---  = 0+0+0 = 0

```shell
# 当前test.java 权限为 rw-r--r--
[root@reanon home]# ll
-rw-r--r-- 1 root root    0 Sep 24 21:51 test.java
# 修改权限:权限为 rwxrwx---
[root@reanon home]# chmod 770 test.java 
-rwxrwx--- 1 root root    0 Sep 24 21:51 test.java
```

#### chown 更改文件属主

chown：Change owner

- 修改文件所有者：chown newowner file
- 修改文件的所有者和所有组：chown newowner:newgroup file 

语法格式：`chown [–R] newowner file` 或`chown [–R] newowner:newgroup file`

- -R：如果是目录则使其下所有子文件或目录递归生效

```shell
# 将/home/abc .txt 文件的所有者修改成tom
[root@reanon test]# chown dfliu abc
-rw-rwxr-x 1 dfliu root   0 Oct 13 17:55 abc
# 将/home/kkk 目录下所有的文件和目录的所有者都修改成tom
[root@reanon home]# chown -R dfliu test/
[root@reanon home]# cd test/
[root@reanon test]# ll
-rw-rwxr-x 1 dfliu root   0 Oct 13 17:55 abc
-rw-r--r-- 1 dfliu root  49 Oct 13 20:39 hello.txt
-rw-r--r-- 1 dfliu root 537 Oct 13 20:56 mytest.zi
```

#### chgrp 更改文件属组

chgrp：Change group

- 修改文件所在的组：chgrp newgroup file

语法格式：`chgrp [-R] newgroup file`

- -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。

```shell
# 请将/home/test/abc.txt 文件的所在组修改成shaolin (少林)
[root@reanon test]# chgrp shaolin /home/test/abc 
-rw-rwxr-x 1 tom shaolin   0 Oct 13 17:55 abc
# 请将/home/test 目录下所有的文件和目录的所在组都修改成shaolin(少林)
[root@reanon test]# chgrp -R shaolin /home/test
-rw-rwxr-x 1 tom shaolin   0 Oct 13 17:55 abc
-rw-r--r-- 1 tom shaolin  49 Oct 13 20:39 hello.txt
-rw-r--r-- 1 tom shaolin 537 Oct 13 20:56 mytest.zip
```



### 文件管理

Linux系统中使用以下命令来查看文件的内容：

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号
- more 一页一页的显示文件内容
- ==less 与 more 类似，但是比 more 更好的是，他可以往前翻页！==
- head 只看头几行
- tail 只看尾巴几行

你可以使用 `man [命令]`来查看各个命令的使用文档，如 ：man cp

#### cat 命令

[cat](https://www.runoob.com/linux/linux-comm-cat.html)：concatenate [v. 连接，连结，使连锁]

- 命令用于连接文件并打印到标准输出设备上。

语法格式：`cat [-AbeEnstTuv] fileName`

- -n 或 --number：由 1 开始对所有输出的行数编号。
- -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。
- -s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。
- -v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。
- -E 或 --show-ends : 在每行结束处显示 $。
- -T 或 --show-tabs: 将 TAB 字符显示为 ^I。
- -A, --show-all：等价于 -vET。
- -e：等价于"-vE"选项；
- -t：等价于"-vT"选项；

```shell
# 切换到网络配置文件目录下
[root@reanon reanon]# cd /etc/sysconfig/network-scripts/

# 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/
[root@reanon network-scripts]# cat ifcfg-eth0 
# Created by cloud-init on instance boot automatically, do not edit.
...
BOOTPROTO=dhcp
DEVICE=eth0
ONBOOT=yes
STARTMODE=auto
TYPE=Ethernet
USERCTL=no

# 倒着读
[root@reanon network-scripts]# tac ifcfg-eth0 
USERCTL=no
TYPE=Ethernet
STARTMODE=auto
ONBOOT=yes
DEVICE=eth0
BOOTPROTO=dhcp
...
```

#### nl  显示行号

nl：Number of Lines

- 显示文件时带着行号

语法格式：`nl [-bnw] [文件名称]`

- -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；
- -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；
- -w ：行号栏位的占用的位数。

```shell
# 显示带行号
[root@reanon network-scripts]# nl ifcfg-eth0 
     1	# Created by cloud-init on instance boot automatically, do not edit.
     2	# If you don't want cloud-init genrated automatically,you can disable it in /etc/cloud/cloud.cfg
     3	# For more information, please refer to: https://help.aliyun.com/document_detail/57803.html
     4	#
     5	BOOTPROTO=dhcp
     6	DEVICE=eth0
     7	ONBOOT=yes
     8	STARTMODE=auto
     9	TYPE=Ethernet
    10	USERCTL=no
```

#### more 查看

more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。

语法格式：`more [要查看的文件]`  

快捷键

- 向下翻一页：空白键(space)
- 向下翻『一行』：Enter
- 立刻离开more,不再显示该文件内容：q
- 向下滚动一屏：Ctrl+F
- 返回上一屏：Ctrl+B
- 输出当前行的行号：`=`
- 输出文件名和当前行的行号：`:f`
- 向下搜寻『字串』这个关键字：`/字串` 

```shell
[root@reanon etc]# more /etc/csh.login
....(中间省略)....
--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令

# 按:f
...
"csh.login" line 19

```

#### less 查看

less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，==对于显示大型文件具有较高的效率。==

语法格式：`less [要查看的文件]`  

快捷键

- 向下翻一页：空白键(space)
- 立刻离开less,不再显示该文件内容：q
- 向下翻动一页：[pagedown]
- 向上翻动一页：[pageup]
- 向下搜寻『字串』的功能：`/字串`
  - 向上查找：n
  - 向下查找：N
- 向上搜寻『字串』的功能：`?字串`
  - 向上查找：n
  - 向下查找：N

```shell
# 退出得按 q
[root@reanon etc]# less /etc/csh.login
....(中间省略)....
:   # 这里可以等待你输入命令！
```

#### echo 指令

echo：

- 输出内容到控制台

语法格式：`echo [选项] [输出内容]`

```shell
# 使用echo指令输出环境变量.输出当前的环境路径
[root@reanon home]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/var/lib/snapd/snap/bin:/usr/java/jdk1.8.0_261-amd64/bin:/usr/java/jdk1.8.0_261-amd64/jre/bin:/root/bin
```



#### head 指令

head：

- 显示文件的开头部分内容(默认情况下head指令显示文件的前10行内容)

语法格式：`head [-n number] [文件名称]`

- -n：查看文件头n行内容

```
# 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：
[root@reanon etc]# head -n 20 /etc/csh.login 
# /etc/csh.login

# System wide environment and startup programs, for login setup

if ( ! ${?PATH} ) then
...
```

#### tail 指令

tail：

- 输出文件中尾部的内容(默认情况下tail指令显示文件的前10行内容)

语法格式：`tail [-n number] [文件名称]`

- -n：查看文件后n行内容
- -f：实时追踪该文档的所有更新

```shell
# 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样
[root@reanon etc]# head -n 20 /etc/csh.login 
# /etc/csh.login
...
        end
        unset i nonomatch
endif

```



#### >  输出重定向

- 输出重定向，会将原来文件的内容覆盖

语法格式：`... > [文件名称]`

常用命令

- 列表的内容写入文件中（覆盖写）：ls -l > 文件
- 将文件1的内容覆盖到文件2：cat 文件1 > 文件2

```shell
# 功能描述：列表的内容写入文件中（覆盖写）
[root@reanon home]# ls -l > test.txt 
[root@reanon home]# cat test.txt 
total 28
drwx------ 2 dfliu dfliu 4096 Oct 13 15:50 dfliu
...
# 功能描述：将文件1的内容覆盖到文件2
[root@reanon home]# cat test.txt > c.txt
[root@reanon home]# cat c.txt 
total 28
drwx------ 2 dfliu dfliu 4096 Oct 13 15:50 dfliu
...
```

#### >> 追加

- 追加，不会覆盖原来文件的内容，而是追加到文件的尾部

语法格式：`... >> [文件名称]`

常用命令

- 列表的内容追加到文件的末尾：ls -al >> 文件
- 将内容追加到文件中：echo "内容" >> 文件

```shell
# 将内容追加到文件中
[root@reanon home]# cat c.txt 
total 28
..
total 36
...
```

#### ln 链接

ln：link files

- 为某一个文件在另外一个位置建立一个同步的链接

Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）；ln 命令产生硬链接

- 硬链接∶A---B，假设B是A的硬链接，那么他们两个指向了同一个文件；允许一个文件拥有多个路径，用户可以通过这种机制建立硬链接到一些重要文件上，防止误删!

- 软链接∶类似Window下的快捷方式，删除的源文件，快捷方式也访问不了!

语法格式：`ln [参数] [源文件或目录] [目标文件或目录]`

- -s：

```shell
[root@reanon reanon]# rm -rf f1
[root@reanon reanon]# ls
build  f2  f3  test1
[root@reanon reanon]# cat f2
whoami
[root@reanon reanon]# cat f3
cat: f3: No such file or directory
# 创建文件
[root@reanon reanon]# touch f1

# 创建f1的一个硬连接文件f2
[root@reanon reanon]# ln f1 f2

# 创建f1的一个符号连接文件f3
[root@reanon reanon]# ln -s f1 f3
[root@reanon reanon]# ll
...
-rw-r--r-- 2 root root    0 Oct 12 20:41 f1
-rw-r--r-- 2 root root    0 Oct 12 20:41 f2
lrwxrwxrwx 1 root root    2 Oct 12 20:43 f3 -> f1
# 给f1 文件中写入内容
[root@reanon reanon]# echo "whoami" >> f1
# f2、f3都有内容
[root@reanon reanon]# cat f2
whoami
[root@reanon reanon]# cat f3
whoami
```

链接的话会显示有其他颜色

![image-20201012204353188](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201012204353.png)

```shell
# 删除源文件
[root@reanon reanon]# rm -rf f1
[root@reanon reanon]# ls
build  f2  f3  test1
# 硬链接的文件还在
[root@reanon reanon]# cat f2
whoami
# 软链接的文件无法访问
[root@reanon reanon]# cat f3
cat: f3: No such file or directory
```

如果链接原文件被删除，也会变颜色

![image-20201012204801161](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201012204801.png)

#### history 查看历史

history：

- 查看已经执行过历史命令,也可以执行历史指令
- 该命令单独使用时，仅显示历史命令
- 在命令行中，可以使用符号`!`执行指定序号的历史命令，如`!2`执行第2个历史命令

语法格式：`history [选项] number` 

- -c：清空当前历史命令；
- -a：将历史命令缓冲区中命令写入历史命令文件中；
- -r：将历史命令文件中的命令读入当前历史命令缓冲区；
- -w：将当前历史命令缓冲区命令写入历史命令文件中。

```shell
# 查看已经执行过历史命令
[root@reanon home]# history
    1  sudo yum remove docker                   docker-client                   docker-client-latest                   docker-common             ...
934  history
# 显示最近使用过的10个指令
[root@reanon home]# history 10
  926  cat c.txt 
  927  ls -l >> c.txt 
  928  cat c.txt 
  929  echo $PATH
  930  history
  931  clear
  932  history
  933  clear
  934  history
  935  history 10

# 执行历史编号为935的指令
[root@reanon home]# !935
history 10
  928  cat c.txt 
...

```

### 时间日期

#### date 显示当前日期

date：

- 显示当前日期

语法格式：`date [选项] +时间日期格式`

- -d<字符串>：显示字符串所指的日期与时间。字符串前后必须加上双引号；
- -s<字符串>：根据字符串来设置日期与时间。字符串前后必须加上双引号；
- -u：显示GMT；

显示当前日期

- 显示当前时间：date
- 显示当前年份：date +%Y
- 显示当前月份：date +%m
- 显示当前是哪一天：date +%d
- 显示年月日时分秒：date "+%Y-%m-%d %H:%M:%S"

设置时间：date -s

- 设置全部时间：date -s "2012-05-23 01:01:01"
- 获取系统硬件时间：hwclock
- 设置操作系统的软件时间，与系统硬件时间同步：hwclock -s

```shell
# 显示当前时间
[root@reanon home]# date
Tue Oct 13 20:14:59 CST 2020
# 显示当前年份
[root@reanon home]# date +%Y
2020
# 显示当前月份
[root@reanon home]# date +%m
10
# 显示当前是哪一天
[root@reanon home]# date +%d
13
# 显示年月日时分秒
[root@reanon home]# date "+%Y-%m-%d %H:%M:%S"
2020-10-13 20:16:11
# 设置系统当前时间
[root@reanon ~]# date -s "2012-05-23 01:01:01"
Wed May 23 01:01:01 CST 2012
# 获取系统硬件时间
[root@reanon ~]# hwclock
Tue 13 Oct 2020 08:25:43 PM CST  -0.523983 seconds
#设置操作系统的软件时间，与系统硬件时间同步
[root@reanon ~]# hwclock -s
# 显示当前时间
[root@reanon ~]# date
Tue Oct 13 20:25:53 CST 2020
```

#### cal 查看日历

cal：Calendar(日历)

- 查看日历

语法格式：`cal [选项]`

```
# 显示本月日历
# [root@reanon ~]# cal
    October 2020    
Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31
# 显示当前日历
[root@reanon ~]# cal 2020
```

#### crontab 任务调度

crond：

- 定时任务的设置；
- 任务调度：是指系统在某个时间执行的特定的命令或程序。任务调度分类：
  1. 系统工作：有些重要的工作必须周而复始地执行，如病毒扫描等
  2. 个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。

语法格式：`crontab [选项]`

- -e：编辑crontab定时任务
- -l：列出当前有那些任务调度
- -r：删除当前用户所有的crontab任务

常见指令

- service crond restart：重启任务调度

基本步骤

1. 设置任务调度文件：`/etc/crontab`
2. 设置个人任务调度。执行crontab –e命令。
3. 接着输入任务到调度文件如：`*/1 * * * * ls –l /etc/ > /tmp/to.txt`：意思说每小时的每分钟执行`ls –l /etc/ > /tmp/to.txt`命令

参数细节

1. 5个占位符的说明：分 时 天 月 星期

   | 项目       | 含义                 | 范围                    |
   | ---------- | -------------------- | ----------------------- |
   | 第一个 `*` | 一小时当中的第几分钟 | 0-59                    |
   | 第二个`*`  | 一天当中的第几小时   | 0-23                    |
   | 第三个`*`  | 一个月当中的第几天   | 1-31                    |
   | 第四个`*`  | 一年当中的第几月     | 1-12                    |
   | 第五个`*`  | 一周当中的星期几     | 0-7（0和7都代表星期日） |

2. 特殊符号的说明

   | 特殊符号 | 含义                                                         |
   | :------: | :----------------------------------------------------------- |
   |    *     | 代表任何时间。比如第一个`*`就代表一小时中每分钟都执行一 次的意思。 |
   |    ,     | 代表不连续的时间。比如`0 8,12,16 * * *`命令，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 |
   |    -     | 代表连续的时间范围。比如`0 5 * * 1-6`命令，代表在周一到周六的凌晨5点0分执行命令 |
   |   */n    | 代表每隔多久执行一次。比如`*/10 * * * *`命令，代表每隔 10分钟就执行一遍命令 |

3. 特定时间执行任务案例

   | 时间            | 含义                                                         |
   | --------------- | ------------------------------------------------------------ |
   | `45 22 * * *`   | 在22点45分执行命令                                           |
   | `0 17 * * 1`    | 每周1的17点0分执行命令                                       |
   | `0 5 1,15 * *`  | 每月1号和15号的凌晨5点0分执行命令                            |
   | `40 4 * * 1-5`  | 每周一到周五的凌晨4点40分执行命令                            |
   | `*/10  4 * * *` | 每天的凌晨4点，每隔10分钟执行一次命令                        |
   | `0 0 1,15 * 1`  | 每月1号和15号，每周1的0点0分都会执行命令。注意:星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。 |

```shell
##  案例1：每隔1分钟，就将当前的日期信息，追加到/tmp/mydate 文件中
# 1、先编写一个脚本文件 /home/mytask1.sh
[root@reanon test]# vim mytask1.sh
[root@reanon test]# cat mytask1.sh 
date >> /tmp/mydate
# 2、给mytask1.sh一个可以执行权限:chmod 744 /home/test/mytask1.sh
[root@reanon test]# chmod u+x mytask1.sh
# 3、编写任务调度文件：crontab -e；写入内容：*/1 * * * * /home/test/mytaskl.sh
[root@reanon test]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
# 列出当前有哪些任务调度
[root@reanon test]# crontab -l
*/1 * * * * /home/test/mytask1.sh
# 确实有数据
[root@reanon test]# cd /tmp/
[root@reanon tmp]# cat mydate 
Wed Oct 14 10:17:01 CST 2020
Wed Oct 14 10:18:01 CST 2020
Wed Oct 14 10:19:01 CST 2020
# 终止任务调度
[root@reanon tmp]# crontab -r
[root@reanon tmp]# crontab -l
no crontab for root

##  案例2：每隔1分钟，将当前日期和日历都追加到/home/mycal 文件中
# 1、先编写一个脚本文件/home/mytask2.sh，写入内容：date >>/tmp/mycal   cal >>/tmp/mycal
# 2、给mytask1.sh一个可以执行权限：chmod 744 /home/mytask2.sh
# 3、 编写任务调度文件：crontab -e，写入内容：*/1**** /home/mytask2.sh

## 案例3: 每天凌晨2:00 将mysql数据库testdb ，备份到文件中。
# 1、先编写一个文件/home/mytask3.sh；内容为：/usr/local/mysql/bin/mysqldump -u root -proot testdb > /tmp/mydb.bak
# 2、给mytask3.sh一个可以执行权限：chmod 744/home/mytask3.sh
# 3、编写任务调度文件：crontab -e；写入内容：0 2 * * * /home/mytask3.sh
```

### 搜索查找

#### find 查找

find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。

语法格式：`find [搜索范围] [选项]`

- -name <查询方式>：按照指定的文件名查找模式查找文件
- -user <用户名>：查找属于指定用户名所有文件
- -size <文件大小>：按照指定的文件大小查找文件（+n 大于-n小于n等于）。

```shell
# 案例1: 按文件名：根据名称查找/home 目录下的hello.txt文件
[root@reanon ~]# find /home -name test.txt
/home/test/test.txt
/home/test.txt
...
# 案例2：按拥有者：查找/opt目录下，用户名称为nobody的文件
[root@reanon ~]# find /opt -user dfliu
# 案例3：查找整个linux系统下大于200m的文件（+n 大于-n小于n等于）
[root@reanon ~]# find / -size +200M
/proc/kcore
find: ‘/proc/1871/task/1871/fd/6’: No such file or directory
...
# 查询/目录下，所有.txt 的文件
[root@reanon ~]# find / -name *.txts
```



#### locate 定位

locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。

语法格式：`locate [搜索文件]`

- updatedb指令：第一次运行前，用于创建locate数据库

```
# 必须使用updatedb指令创建locate数据库。

```



#### grep 过滤查找

grep：

- 过滤查找

语法格式：`grep [选项] 查找内容源文件`

- -n：显示匹配行及行号。
- -i：忽略字母大小写

#### |  管道符号

- 表示将前一个命令的处理结果输出传递给后面的命令处理；

```shell
# 请在hello.txt 文件中，查找"yes" 所在行，并且显示行号
[root@reanon test]# cat hello.txt | grep -n yes
1:yes
3:yes
5:yes
13:yes
# 不区分大小写
[root@reanon test]# cat hello.txt | grep -ni yes
1:yes
3:yes
5:yes
8:gsg yES
11:YEsgag
12:sagYeS
13:yes
```

### 压缩解压

#### gzip/gunzip

gzip 用于压缩文件，gunzip 用于解压的

gzip：

- 压缩文件，只能将文件压缩为*.gz文件

语法格式：`gzip [文件名称]`

gunzip：

- 解压缩文件

语法格式：`gunzip [文件名称].gz`

```shell
# 压缩;当我们使用gzip 对文件进行压缩后，不会保留原来的文件。
[root@reanon test]# gzip hello.txt test.txt 
[root@reanon test]# ll
-rw-r--r-- 1 root root 65 Oct 13 20:39 hello.txt.gz
-rw-r--r-- 1 root root 29 Oct 13 17:55 test.txt.gz
# 解压缩
[root@reanon test]# gunzip hello.txt.gz test.txt.gz 
[root@reanon test]# ll
-rw-r--r-- 1 root root 49 Oct 13 20:39 hello.txt
-rw-r--r-- 1 root root  0 Oct 13 17:55 test.txt
```

#### zip/unzip

zip 用于压缩文件，unzip 用于解压的，这个在项目打包发布中很有用的

zip：

- 压缩文件

语法格式：`zip [选项] XXX.zip`

- -r：递归压缩，即压缩目录

unzip：

- 解压缩文件

语法格式：`unzip [选项] XXX.zip`

- -d <目录> ：指定解压后文件的存放目录

```shell
# 将/home/test下的所有文件进行压缩成mypackage.zip
[root@reanon test]# zip -r mytest.zip /home/test/
  adding: home/test/ (stored 0%)
  adding: home/test/test.txt (stored 0%)
  adding: home/test/hello.txt (deflated 24%)
# 将mypackge.zip 解压到/opt/目录下
[root@reanon test]# unzip -d /opt/ mytest.zip 
Archive:  mytest.zip
   creating: /opt/home/test/
 extracting: /opt/home/test/test.txt  
  inflating: /opt/home/test/hello.txt
```

#### tar 打包

tar：Tape archive（磁带存档）

- 打包指令，最后打包后的文件是.tar.gz 的文件

语法格式：`tar [选项] XXX.tar.gz 打包的内容`

- -z或--gzip或--ungzip：通过gzip指令处理备份文件
- -c或--create：建立新的备份文件
- -v或--verbose：显示指令执行过程；
- -f<备份文件> 或--file= <备份文件>：指定备份文件
- -x或--extract或--get：从备份文件中还原文件
- -C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
- -A或--catenate：新增文件到以存在的备份文件；
- -j：支持bzip2解压文件；
- -t或--list：列出备份文件的内容

常用命令

- 仅打包，不压缩：tar -cvf package_name.tar.gz  [文件]
- 打包后，以 gzip 压缩 ：tar -zcvf  package_name.tar.gz  [文件]
- 打包后，以 bzip2 压缩：tar -jcvf package_name.tar.gz  [文件]
- 解压文件：tar -zxvf  package_name.tar.gz 
- 解压文件到指定目录下：tar -zxvf  package_name.tar.gz  -C [目录]

```shell
# 压缩多个文件，将/home/test.txt 和/home/test 压缩成a.tar.gz
[root@reanon home]# tar -zcvf a.tar.gz  test test.txt 
test/
test/mytest.zip
test/test.txt
test/hello.txt
test.txt
# 将/test 的文件夹压缩成myhome.tar.gz
[root@reanon home]# tar -zcvf mytest.tar.gz /home/test
tar: Removing leading `/' from member names
/home/test/
/home/test/mytest.zip
/home/test/test.txt
/home/test/hello.txt
# 将a.tar.gz 解压到当前目录
[root@reanon home]# tar -zxvf a.tar.gz 
test/
test/mytest.zip
test/test.txt
test/hello.txt
test.txt
# 将mytest.tar.gz 解压到/opt/目录下,指定解压到的那个目录，事先要存在才能成功，否则会报错。
[root@reanon home]# tar -zxvf mytest.tar.gz -C /opt/
home/test/
home/test/mytest.zip
home/test/test.txt
home/test/hello.txt
[root@reanon home]# ls /opt/home/test/
hello.txt  mytest.zip  test.txt
```



：

语法格式：`touch [文件名称]`

- 

：

- 创建空文件

语法格式：`touch [文件名称]`

- 

：

- 创建空文件

语法格式：`touch [文件名称]`

- 

### 用户管理

Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。

用户和组的相关文件

- /etc/passwd 文件：用户（user）的配置文件，记录用户的各种信息
  每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
- /etc/shadow 文件：口令的配置文件
  每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
- /etc/group 文件：组(group)的配置文件，记录Linux包含的组的信息
  每行含义：组名:口令:组标识号:组内用户列表

#### hostname 主机名

hostname：

- 显示和设置系统的主机名称

语法格式：`hostname [可选项] [hostname]`

- -v：详细信息模式；
- -a：显示主机别名；
- -d：显示DNS域名；
- -f：显示FQDN名称；
- -i：显示主机的ip地址；
- -s：显示短主机名称，在第一个点处截断；
- -y：显示NIS域名。
- [hostname]：指定要设置的主机名

```shell
# 查看主机名
[dfliu@reanon reanon]$ hostname
reanon
# 设置主机名为 reanon，重启后生效
[dfliu@reanon reanon]$ hostname reanon
```

#### useradd  添加用户

[useradd](https://www.runoob.com/linux/linux-comm-useradd.html)：

- 用于添加用户帐号

语法格式：`useradd [可选项] [用户帐号]`

- -c (comment)：指定一段注释性描述。备注文字会保存在passwd的备注栏位中
- -d <登入目录>：指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
- -g <用户组>：指定用户所属的用户组。
- -G <用户组>：指定用户所属的附加组
- -m：使用者目录如不存在则自动建立。
- -u <uid> ：指定用户ID
- -r ：建立系统帐号。

```shell
# 此命令创建了一个用户dfliu，其中-m选项用来为登录名dfliu产生一个主目录 /home/dfliu
[root@reanon home]# useradd -m dfliu
[root@reanon home]# ll
drwx------ 2 dfliu dfliu 4096 Oct 13 09:45 dfliu
...
# 增加组
[root@reanon ~]# groupadd wudang
# 增加用户时直接加上组
[root@reanon ~]# useradd -g wudang zwj
# 查看用户信息
[root@reanon ~]# id zwj
uid=1001(zwj) gid=1001(wudang) groups=1001(wudang)
# 修改用户的组
[root@reanon ~]# groupadd shaolin
[root@reanon ~]# usermod -g shaolin zwj
[root@reanon ~]# id zwj
uid=1001(zwj) gid=1002(shaolin) groups=1002(shaolin)
```

增加用户账号就是在`/etc/passwd`文件中为新用户增加一条记录，同时更新其他系统文件如`/etc/shadow`、 `/etc/group`等。

```shelldd
[root@reanon home]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
...
dfliu:x:1000:1000::/home/dfliu:/bin/bash
```

#### passwd 指定/修改密码

[passwd](https://www.runoob.com/linux/linux-comm-passwd.html)：

- 用来更改用户的密码

语法格式：`passwd [可选项] [username]`

- -S 显示密码信息
- -d 删除口令，使账号无口令
- -l (lock) ：锁定口令，即禁用账号。
- -u 口令解锁。
- -f 强迫用户下次登录时修改口令。

超级用户的话

```shell
# 超级用户下修改用户密码
[root@reanon reanon]# passwd dfliu
Changing password for user dfliu.
New password: 
Retype new password: 
passwd: all authentication tokens updated successfully.

# 普通用户下修改用户密码，需要输入当前密码才可以就解开
[dfliu@reanon reanon]$ passwd 
Changing password for user dfliu.
Changing password for dfliu.
(current) UNIX password: 
New password: 
...
# 锁定某一用户
[root@reanon reanon]# passwd -l dfliu
Locking password for user dfliu.
passwd: Success
# 解锁某一用户
[root@reanon reanon]# passwd -u dfliu
Unlocking password for user dfliu.
passwd: Success
```

#### userdel 删除用户

userdel：

- 用于删除用户帐号

语法格式：`userdel [可选项] [username]`

- -r ：删除用户登入目录以及目录中所有文件

```shell
# 此命令删除用户dfliu在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。
[root@reanon home]# userdel -r dfliu
```

#### usermod 修改组

usermod：

- 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

语法格式：语法格式：`usermod [可选项] [用户帐号]`

- -c (comment)：修改用户帐号的备注文字。
- -d <登入目录>：修改用户主目录
- -u <uid>：修改用户ID；
- -g <用户组>：修改用户所属的用户组。
- -G <用户组>：修改用户所属的附加组
- -l<帐号名称>：修改用户帐号名称；
- -L：锁定用户密码，使密码无效；
- -s<shell>：修改用户登入后所使用的shell
- -U:解除密码锁定。
- -e<有效期限>：修改帐号的有效期限
- -f<缓冲天数>：修改在密码过期后多少天即关闭该帐号

常用命令：

- usermod –g [组名] [用户名]：改变用户所在组
- usermod –d [目录名] [用户名]：改变该用户登陆的初始目录
- usermod -l [username] [newusername]：修改newuser的用户名
- usermod -L [用户名] ：锁定用户
- usermod -U [用户名]解除对用户的锁定

```shell
# 修改用户的主目录
[root@reanon home]# usermod -d /home/223 dfliu
# 查看用户配置文件
[root@reanon home]# cat /etc/passwd
...
dfliu:x:1000:1000::/home/223:/bin/bash
# 将newuser2添加到组staff中
usermod -G staff newuser2
# 修改newuser的用户名为newuser1
usermod -l newuser1 newuser
# 锁定账号newuser1
usermod -L newuser1
# 解除对newuser1的锁定
usermod -U newuser1
```



#### id 查询用户

id：

- 用于显示用户的ID，以及所属群组的ID

语法格式：`id [可选项] [username]`

```
# 查询root 信息
[root@reanon ~]# id root
uid=0(root) gid=0(root) groups=0(root)
```

#### su 切换用户

su：swith user

- 切换用户；从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。当需要返回到原来用户时，使用`exit`指令

语法格式：`su [username]`

常用命令

1. 切换用户的命令为：su username
2. 从普通用户切换到root用户：sudo su
3. 退回到原来用户：终端输入`exit`、`logout`、使用快捷方式`ctrl+d`
4. 在切换用户时，在切换用户之后使用新用户的工作环境，可以在su和username之间加 `-`：`su - root`
5. 用户模式
   1. 普通用户：`$`
   2. 超级用户（root用户）：`#`

```
# 切换用户
[root@reanon ~]# su - dfliu 
Last login: Tue Oct 13 10:33:30 CST 2020 on pts/0
[dfliu@reanon ~]$ exit
logout
[root@reanon ~]# 
```



#### whoami 查看当前用户

- 用于显示自身用户名称

语法格式：`whoami`

- 相当于执行：`id -un`

### 用户组管理

在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件
有所有者、所在组、其它组的概念。

- 查看文件的所有者：ls –ahl
- 修改文件所有者：chown [用户名] [文件名]

#### groupadd 新增组

groupadd：

- 建一个新的工作组，新工作组的信息将被添加到系统文件中
  - /etc/group 组账户信息。
  - /etc/gshadow 安全组账户信息。
  - /etc/login.defs Shadow密码套件配置。

语法格式：`groupadd [-g gid [-o]] [-r] [-f] group`

- -g：指定新用户组的组标识号（GID）；
- -o：一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

```shell
# 创建一个用户组
[root@reanon reanon]# groupadd group
# 查看组配置信息
[root@reanon reanon]# cat /etc/group
root:x:0:
...
group:x:1001:

# 增加了一个新组group1，同时指定新组的组标识号是520
[root@reanon reanon]# groupadd -g 520  group1
[root@reanon reanon]# cat /etc/group
...
group:x:1001:
group1:x:520:

# 增加组
[root@reanon ~]# groupadd wudang
# 增加用户时直接加上组
[root@reanon ~]# useradd -g wudang zwj
# 查看用户信息
[root@reanon ~]# id zwj
uid=1001(zwj) gid=1001(wudang) groups=1001(wudang)
# 修改用户的组
[root@reanon ~]# groupadd shaolin
[root@reanon ~]# usermod -g shaolin zwj
[root@reanon ~]# id zwj
uid=1001(zwj) gid=1002(shaolin) groups=1002(shaolin)
```

#### groupdel 删除组

groupdel：group delete

- 删除群组；如果该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

语法格式：`groupdel [用户组名]`

```shell
# 从系统中删除组group1
[root@reanon reanon]# groupdel group1
```

#### groupmod 修改组

groupmod：group delete

修更改用户组Gid或组名

语法格式：`groupmod [-g <Gid> <-o>] [-n <新用户组名称>] [用户组名称]`

- -g：GID 为用户组指定新的组标识号。
- -o：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n：新用户组，将用户组的名字改为新名字

```shell
# 查看原组信息，查看文件最后一行信息
[root@reanon reanon]# tail -1 /etc/group
group:x:1001:
# 修改组名
[root@reanon reanon]# groupmod -n groupmoded group
# 再次查看
[root@reanon reanon]# tail -1 /etc/group
groupmoded:x:1001:

# 此命令将组group的组标识号修改为101
[root@reanon reanon]# groupmod -g 101  groupmoded
[root@reanon reanon]# tail -1 /etc/group
groupmoded:x:101:
```

#### /etc/passwd

Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，每行记录又被冒号(:)分隔为7个字段，它记录了这个用户的一些基本属性，其格式和具体含义如下：

>用户名:口令(登录密码):用户标识号:组标识号:注释性描述:主目录:登录Shell

1. "用户名"是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。
2. “口令”一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到`/etc/shadow`文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。
3. “用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。通常用户标识号的取值范围是0～65 535。==0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始==。在Linux系统中，这个界限是500。
4. “组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。
5. “注释性描述”字段记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。
6. “主目录”，也就是用户的起始工作目录。它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。
7. 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。==常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等==。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为==/bin/sh==。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。
8. 系统中有一类用户称为伪用户（pseudo users）。这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户含义：
   1. bin：拥有可执行的用户命令文件
   2. sys：拥有系统文件
   3. adm：拥有帐户文件
   4. uucp：UUCP使用
   5. lp：lp或lpd子系统使用
   6. nobody：NFS使用

#### /etc/shadow

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。

- 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。

/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生；它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用":"隔开。这些字段是：

> 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志

1. "登录名"：是与/etc/passwd文件中的登录名相一致的用户账号
2. "口令"字段：存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
3. "最后一次修改时间"：表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
4. "最小时间间隔"：指的是两次修改口令之间所需的最小天数。
5. "最大时间间隔"：指的是口令保持有效的最大天数。
6. "警告时间"字段：表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7. "不活动时间"：表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8. "失效时间"字段：给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

#### /etc/group

用户组的所有信息都存放在/etc/group文件中。将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用`newgrp命令`使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：

> 组名:口令:组标识号:组内用户列表

1. "组名"：是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
2. "口令"字段：存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
3. "组标识号"：与用户标识号类似，也是一个整数，被系统内部用来标识组。
4. "组内用户列表"：是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

### 磁盘管理

Linux磁盘管理好坏直接关系到整个系统的性能问题。

#### 磁盘分区

分区的方式：

1. mbr分区:
   - 最多支持四个主分区
   - 系统只能安装在主分区
   - 扩展分区要占一个主分区
   - MBR最大只支持2TB，但拥有最好的兼容性
2. gpt分区:
   - 支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）
   - 最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）
   - windows7 64位以后支持gpt

![image-20201014102707106](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201014102707.png)

linux分区原理

1. Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构, Linux中每个分区都是用来组成整个文件系统的一部分。

2. Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。

   ![Linux 分区和挂载概念](https://forum.suse.org.cn/uploads/default/original/1X/472c3fd32fb207f36ae57d6681ca0fcf3132ca97.png)

硬盘说明

1. Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘
2. 对于IDE硬盘，驱动器标识符为 `hdx~` ，其中`hd`表明分区所在设备的类型，这里是指IDE硬盘了。`~`代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。`x`为盘号：
   1. a为基本盘
   2. b为基本从属盘
   3. c为辅助主盘
   4. d为辅助从属盘
      - 例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。
3. 对于SCSI硬盘则标识为`sdx~`，SCSI硬盘是用`sd`来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。

#### lsblk  设备挂载情况

lsblk： list block 

- 查看所有设备挂载情况

语法格式：`lsblk [选项]`

- -f ：查看系统分区和挂载情况

![image-20201014104332920](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201014104333.png)

添加一个新硬盘

1. 1)虚拟机添加硬盘
   2)分区
   3)格式化
   4)挂载
   5)设置可以自动挂载。

![image-20201014104447895](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201014104448.png)



Linux磁盘管理常用命令为 df、du。

- df ：列出文件系统的整体磁盘使用量
- du：检查磁盘空间使用量

#### df 

df： disk free

- 检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息

语法格式：`df [-ahikHTm] [目录或文件名]`

- -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
- -k ：以 KBytes 的容量显示各文件系统；
- -m ：以 MBytes 的容量显示各文件系统；
- -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
- -H ：以 M=1000K 取代 M=1024K 的进位方式；
- -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
- -i ：不用硬盘容量，而以 inode 的数量来显示

```shell
# 在 Linux 底下如果 df 没有加任何选项
# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！
[root@reanon reanon]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
...
tmpfs             188204       0    188204   0% /run/user/0

# 以MB单位来显示
[root@reanon reanon]# df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        909M     0  909M   0% /dev
tmpfs           919M     0  919M   0% /dev/shm
tmpfs           919M  756K  919M   1% /run
tmpfs           919M     0  919M   0% /sys/fs/cgroup
/dev/vda1        40G  7.5G   31G  20% /
/dev/loop0       98M   98M     0 100% /var/lib/snapd/snap/core/9993
/dev/loop1       36M   36M     0 100% /var/lib/snapd/snap/solc/6746
tmpfs           184M     0  184M   0% /run/user/0

```

#### du 

du：Disk usage

- 查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看

语法格式：`du [-ahskm] 文件或目录名称`

- -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。
- -h ：以人们较易读的容量格式 (G/M) 显示；
- -s ：列出总量而已，而不列出每个各别的目录占用容量；
- -S ：不包括子目录下的总计，与 -s 有点差别。
- -k ：以 KBytes 列出容量显示；
- -m ：以 MBytes 列出容量显示；

```shell
# 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:
# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。
[root@reanon home]# du
80	./mythril              # 包括隐藏文件的目录
4	./mysql/conf
680	./mysql/data/sys
24884	./mysql/data/mysql
1064	./mysql/data/performance_schema
202800	./mysql/data
202808	./mysql
8	./dockerfile
4	./reanon/build/tomcat/test
4	./reanon/build/tomcat/tomcatlog
201580	./reanon/build/tomcat
201584	./reanon/build
4	./reanon/test1
201596	./reanon
16	./dfliu
404512	.                # 这个目录(.)所占用的总量

# 将文件的容量也列出来
[root@reanon home]# du -a
8	./mythril/rubixi.sol    # 有文件的列表了
...

# 检查根目录底下每个目录所占用的容量
[root@reanon home]# du -sm /*
0	/bin
.....中间省略....
0	/proc
.....中间省略....
1	/tmp
2591	/usr      # 系统初期最大就是它，程序和文件就在这里

```

#### mount 磁盘挂载

根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”

[mount](https://www.runoob.com/linux/linux-comm-mount.html)：

- 挂载Linux系统外的文件

语法格式：`mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点`

```
# 将 /dev/xxx 挂载到 /mnt/xxx 上面！外部设备通过挂载到mnt目录下来实现访问
[root@reanon mnt]# mkdir reanon
[root@reanon mnt]# mount /dev/xxx /mnt/xxx
```

#### umount 卸载磁盘

umount：

- 磁盘卸载

语法格式：`umount [-fn] 装置文件名或挂载点`

- -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；
- -n ：不升级 /etc/mtab 情况下卸除。

```
# 卸载/dev/xxx
[root@reanon mnt]# umount /dev/xxx
```

### vi 和vim

所有的Linux 系统都会内建vi 文本编辑器。
Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

#### 三种操作模式

- 命令模式（Command mode）：以vim 打开一个档案就直接进入一般模式了。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理你的文件数据。
- 插入模式（Insert mode）：按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可.
- 底线命令行模式（Last line mode）：在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim 、显示行号等的动作则是在此模式中达成的！

![Liunx中vi/vim编辑](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201012205810.jpeg)

vi和vim基本快捷键

- 拷贝当前行：`yy` 
  - 拷贝当前行向下的5行：`5yy`，并粘贴：`p`
- 删除当前行：`dd` 
  - 删除当前行向下的5行：5dd
- 查找某个单词(在命令模式)：`/[关键字]`
  - 回车查找；
  - 查找下一个：`n`
- 设置文件的行号(在命令模式)：`:set nu`
- 取消文件的行号：`:set nonu`
- 编辑/etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg]
- 移动到第20行：
  - 显示行号：`:set nu`
  - 输入：20
  - 输入：shift + g

#### 光标移动

| 移动光标的方法     |                                                              |
| :----------------- | ------------------------------------------------------------ |
| h 或 向左箭头键(←) | 光标向左移动一个字符                                         |
| j 或 向下箭头键(↓) | 光标向下移动一个字符                                         |
| k 或 向上箭头键(↑) | 光标向上移动一个字符                                         |
| l 或 向右箭头键(→) | 光标向右移动一个字符                                         |
| [Ctrl] + [f]       | 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)          |
| [Ctrl] + [b]       | 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)           |
| [Ctrl] + [d]       | 屏幕『向下』移动半页                                         |
| [Ctrl] + [u]       | 屏幕『向上』移动半页                                         |
| +                  | 光标移动到非空格符的下一行                                   |
| -                  | 光标移动到非空格符的上一行                                   |
| n< space>          | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 |
| 0 或功能键[Home]   | 这是数字『 0 』：移动到这一行的最前面字符处 (常用)           |
| $ 或功能键[End]    | 移动到这一行的最后面字符处(常用)                             |
| H                  | 光标移动到这个屏幕的最上方那一行的第一个字符                 |
| M                  | 光标移动到这个屏幕的中央那一行的第一个字符                   |
| L                  | 光标移动到这个屏幕的最下方那一行的第一个字符                 |
| G                  | 移动到这个档案的最后一行(常用)                               |
| nG                 | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
| gg                 | 移动到这个档案的第一行，相当于 1G 啊！(常用)                 |
| n< Enter>          | n 为数字。光标向下移动 n 行(常用)                            |

#### 复制粘贴

| 删除、复制与粘贴 |                                                              |
| :--------------- | ------------------------------------------------------------ |
| x, X             | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |
| nx               | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |
| dd               | 删除游标所在的那一整行(常用)                                 |
| ndd              | n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) |
| d1G              | 删除光标所在到第一行的所有数据                               |
| dG               | 删除光标所在到最后一行的所有数据                             |
| d$               | 删除游标所在处，到该行的最后一个字符                         |
| d0               | 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符      |
| yy               | 复制游标所在的那一行(常用)                                   |
| nyy              | n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) |
| y1G              | 复制游标所在行到第一行的所有数据                             |
| yG               | 复制游标所在行到最后一行的所有数据                           |
| y0               | 复制光标所在的那个字符到该行行首的所有数据                   |
| y$               | 复制光标所在的那个字符到该行行尾的所有数据                   |
| p, P             | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) |
| J                | 将光标所在行与下一行的数据结合成同一行                       |
| c                | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |
| u                | 复原前一个动作。(常用)                                       |
| [Ctrl]+r         | 重做上一个动作。(常用)                                       |

#### 搜索替换

| 搜索替换 |                                                              |
| :------- | ------------------------------------------------------------ |
| /word    | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) |
| ?word    | 向光标之上寻找一个字符串名称为 word 的字符串。               |
| n        | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
| N        | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |

#### 编辑模式

| 进入输入或取代的编辑模式 |                                                              |
| :----------------------- | ------------------------------------------------------------ |
| i, I                     | 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) |
| a, A                     | 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) |
| o, O                     | 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) |
| r, R                     | 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) |
| [Esc]                    | 退出编辑模式，回到一般模式中(常用)                           |

#### 底行命令模式

| 指令行的储存、离开等指令                                     |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| :w                                                           | 将编辑的数据写入硬盘档案中(常用)                             |
| :w!                                                          | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |
| :q                                                           | 离开 vi (常用)                                               |
| :q!                                                          | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |
| 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ |                                                              |
| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |
| ZZ                                                           | 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ |
| :w [filename]                                                | 将编辑的数据储存成另一个档案（类似另存新档）                 |
| :r [filename]                                                | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |
| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |
| :! command                                                   | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ |
| :set nu                                                      | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |
| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |



### 进程管理

在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。
每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。每个进程都可能以两种方式存在：

- 前台进程就是用户目前的屏幕上可以进行操作的
- 后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。

一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。

#### ps 查看进程

 [ps](https://www.runoob.com/linux/linux-comm-ps.html) ：process status（进程状态）

- 查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数；类似于 windows 的任务管理器。

语法格式：`ps [options]`

- -aux：查看所有进程
  - -a：显示当前终端的所有进程信息
  - -u：以用户的格式显示进程信息
  - -x：显示后台进程运行的参数
- -ef：以全格式显示当前所有的进程，查看进程的父进程
  - -e：显示所有进程
  - -f：全格式
- -A 列出所有的行程
- -w 显示加宽可以显示较多的资讯

##### ps –aux | grep xxx

System V展示风格

- USER：用户名称
- PID：进程号
- %CPU：进程占用CPU的百分比
- %MEM：进程占用物理内存的百分比
- VSZ：进程占用的虚拟内存大小（单位：KB）
- RSS：进程占用的物理内存大小（单位：KB）
- TT：终端名称,缩写.
- STAT：进程状态
  - S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等
- START：进程的启动时间
- TIME：CPU时间，即进程使用CPU的总时间
- COMMAND：启动进程所用的命令和参数，如果过长会被截断显示

```shell
# 显示系统执行的所有进程
[root@reanon mnt]# ps -aux | more
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 125496  3248 ?        Ss   Sep23   0:20 /usr/lib/systemd/systemd --switched
-root --system --deserialize 2
```

![image-20201013120351841](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201013120351.png)

##### ps -ef|grep xxx

BSD风格

- UID：用户ID
- PID：进程ID
- PPID：父进程ID
- C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高
- STIME：进程启动的时间
- TTY：完整的终端名称
- TIME：CPU时间
- CMD：启动进程所用的命令和参数

```shell
# 以全格式显示当前所有的进程，查看进程的父进程
[root@reanon mnt]# ps -ef | more
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Sep23 ?        00:00:20 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
...
```

#### pstree 进程树

pstree：

- 查看进程树pstree

语法格式：`pstree [选项]`

- -p :显示进程的PID
- -u :显示进程的所属用户

```shell
# 查看进程树
[root@reanon mnt]# pstree -pu
systemd(1)─┬─AliYunDun(13298)─┬─{AliYunDun}(13299)
           │                  ├─{AliYunDun}(13300)
           │                  ├─{AliYunDun}(13311)
...
           ├─sshd(1029)───sshd(5417)───bash(5419)───su(5525)───bash(5526,dfliu)───su(5583,root)───bash(5584)─+++
           ├─systemd-journal(350)
           ├─systemd-logind(469)
           ├─systemd-udevd(380)
           └─tuned(809)─┬─{tuned}(876)
                        ├─{tuned}(877)
                        ├─{tuned}(880)
                        └─{tuned}(882)

# 以树状形式显示用户进程
[root@reanon mnt]# pstree -u root
...
systemd─┬─AliYunDun───22*[{AliYunDun}]
        ├─AliYunDunUpdate───3*[{AliYunDunUpdate}]
        ├─2*[agetty]
...
        ├─systemd-udevd
        └─tuned───4*[{tuned}]
                       
```

#### kill 终止进程

kill or killall ：

- 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。

语法格式：`kill [选项] 进程id` 

- -9：表示强迫进程立即停止

语法格式：`killall 进程名称` 

- 通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用

#### nohup 后台执行

nohup：no hang up（不挂起）

- 在系统后台不挂断地运行命令，退出终端不会影响程序的运行

语法格式：` nohup Command [Arg … ] [&]`

- Command：要执行的命令。
- Arg：参数，可以指定输出文件。
- &：让命令在后台执行，终端退出后命令仍旧执行。

2>&1 解释：将标准错误 2 重定向到标准输出 &1 ，标准输出 &1 再被重定向输入到 runoob.log 文件中。

- 0 – stdin (standard input，标准输入)
- 1 – stdout (standard output，标准输出)
- 2 – stderr (standard error，标准错误输出)

```shell
# 在后台执行 root 目录下的 runoob.sh 脚本
nohup /root/test.sh &

# 如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除
ps -aux | grep "runoob.sh" 

# 在后台执行 root 目录下的 runoob.sh 脚本，并重定向输入到 runoob.log 文件
nohup /root/test.sh > runoob.log 2>&1 &
```



：

- 

语法格式：`cal [选项]`

- 

：

- 

语法格式：`cal [选项]`

- 

### RPM 和YUM

rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。

#### RPM

rpm：redhat package manager（红帽软件包管理器）

- 用于互联网下载包的打包及安装工具

语法格式：`rpm [选项] [参数]`

##### 查询已安装的rpm列表

1. 查询已安装的rpm列表：`rpm –qa | grep xx`

- -aq：查询已安装的rpm列表
  - -a：查询所有套件；
  - -q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户
    - -i：显示套件的相关信息
    - -f <文件>+：查询拥有指定文件的套件

```shell
# 查询软件包是否安装
rpm -q [软件包名]
# 显示系统中所有已经安装的rpm包
rpm -qa
# 显示所有名称中包含 "httpd" 字样的rpm包
rpm -qa | grep httpd
# 获取一个已安装包的软件包信息
rpm -qi [package_name]
# 查询文件所属的软件包
rpm -qf [文件全路径名查询] [文件所属的软件包]
# 显示一个已经安装的rpm包提供的文件列表
rpm -ql package_name
```

```shell
# 获取一个已安装包的软件包信息
[root@reanon ~]# rpm -qi jdk1.8 
Name        : jdk1.8
Epoch       : 2000
...
Edition Runtime Environment.
# 查询软件包中的文件，这个输出文件太多了
[root@reanon ~]# rpm -ql jdk1.8
/usr
/usr/java
...
/usr/java/jdk1.8.0_261-amd64/release
/usr/java/jdk1.8.0_261-amd64/src.zip
# 这样少输出很多，查询软件安装到什么位置了
[root@reanon ~]# rpm -ql jdk1.8 | head -5
/usr
/usr/java
/usr/java/jdk1.8.0_261-amd64
/usr/java/jdk1.8.0_261-amd64/.java
/usr/java/jdk1.8.0_261-amd64/.java/.systemPrefs
# 查询文件所属的软件包，需要是全路径
[root@reanon java]# rpm -qf /usr/java/
jdk1.8-1.8.0_261-fcs.x86_64
```

##### 安装rpm包

1. 安装软件包：rpm -ivh [RPM包全路径名称]

- -i 或 --install package.rpm：安装指定的套件档
- -v：显示指令执行过程
- -h 或 --hash：套件安装时的进度条
- --nodeps：不验证套件档的相互关联性

```shell
# 安装一个rpm包
rpm -ivh package.rpm
# 安装一个rpm包而忽略依赖关系警告
rpm -ivh --nodeps package.rpm  
```

##### 删除rpm包

1. 删除一个rpm包：rpm -e package_name
2. 强制移除一个包：rpm -e --nodeps package_name

- -e 或 --erase package_name：删除指定的套件



##### 安装rpm版本Java1.8

链接：[jdk-8u261-linux-x64.rpm](https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html#license-lightbox)

```shell
# 检查是否有安装openjdk
[root@reanon ~]# java -version
-bash: java: command not found
# 如果有安装openjdk 则卸载

# 安装java rpm
[root@reanon dfliu]# rpm -ivh jdk-8u261-linux-x64.rpm 
warning: jdk-8u261-linux-x64.rpm: Header V3 RSA/SHA256 Signature, key ID ec551f03: NOKEY
Preparing...                          ################################# [100%]
...
	localedata.jar...

# 检查是否安装成功
[root@reanon dfliu]# rpm -qa |grep jdk
jdk1.8-1.8.0_261-fcs.x86_64

# 安装完成后配置环境变量 文件：/etc/profile
[root@reanon dfliu]# vim /etc/profile

JAVA_HOME=/usr/java/jdk1.8.0_261-amd64
CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib
PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin
export PATH CLASSPATH JAVA_HOME

# 让新增的环境变量生效
[root@reanon dfliu]# source /etc/profile
# 测试 java -version
[root@reanon dfliu]# java -version
java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
```

#### YUM

yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。

yum：Yellow dog Updater，Modified

- 

语法格式：`yum [options] [command] [package ...]`

- options：选项包括
  - -h：帮助
  - -y：当安装过程提示选择全部为 "yes"
  - -q：不显示安装的过程等等。
- command：要进行的操作。
- package：安装的包名。

##### 国内 yum 源

1. 首先备份 /etc/yum.repos.d/CentOS-Base.repo

2. 下载对应版本 repo 文件, 放入 /etc/yum.repos.d/ (操作前请做好相应备份)

   1. 网易云yum源：http://mirrors.163.com/.help/centos.html

      ![image-20201013165933974](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201013165934.png)

   2. 阿里云yum源：http://mirrors.aliyun.com/repo/

      ![image-20201013165630190](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201013170000.png)

3. 运行以下命令生成缓存：

   - 删除所有缓存的包和头文件：`yum clean all` 
   - 生成缓存：`yum makecache`

```shell
# 先备份/etc/yum.repos.d/CentOS-Base.repo
[root@reanon yum.repos.d]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
# 下载对应阿里云的 repo 文件, 放入 /etc/yum.repos.d/ 
[root@reanon yum.repos.d]# wget http://mirrors.aliyun.com/repo/Centos-7.repo
# 给repo文件改名
[root@reanon yum.repos.d]# mv Centos-7.repo CentOS-Base.repo

# 清理缓存
[root@reanon yum.repos.d]# yum clean all
Loaded plugins: fastestmirror
Cleaning repos: base docker-ce-stable epel extras updates
Cleaning up list of fastest mirrors
# 生成新的缓存
[root@reanon yum.repos.d]# yum makecache
Loaded plugins: fastestmirror
Determining fastest mirrors
 * base: mirrors.cloud.aliyuncs.com
 * extras: mirrors.cloud.aliyuncs.com
 * updates: mirrors.cloud.aliyuncs.com
...                                                         
```

##### 常用命令：

1. 查询yum服务器是否有需要安装的软件：yum list | grep package_name
2. 列出所有可更新的软件清单命令：yum check-update
3. 更新yum软件包索引：yum makecache fast
4. 更新所有软件命令：yum update
5. 仅安装指定的软件命令：yum install package_name
6. 仅更新指定的软件命令：yum update package_name
7. 列出所有可安裝的软件清单命令：yum list
8. 删除软件包命令：yum remove package_name
9. 查找软件包命令：yum search package_name
10. 清除缓存命令:
    - yum clean packages: 清除缓存目录下的软件包
    - yum clean headers: 清除缓存目录下的 headers
    - yum clean oldheaders: 清除缓存目录下旧的 headers
    - yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers

```shell
# 安装软件
[root@reanon dfliu]# yum install firefox
```



#### yum、dnf 、apt和pkg

[apt、yum、dnf和pkg详解](https://www.linuxprobe.com/aptyum-dnfpkg-diff.html)、[Linux yum 命令](https://www.runoob.com/linux/linux-yum.html)

##### 包管理系统

- RPM：Red hat package manager
- dpkg：Debian package manager
- apt：Advanced package tool（Debian或基于Debian的发行版中提供）
- yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器

| 操作系统                              | 格式        | 工具                          |
| :------------------------------------ | :---------- | :---------------------------- |
| Debian                                | .deb        | apt, apt-cache, apt-get, dpkg |
| Ubuntu                                | .deb        | apt, apt-cache, apt-get, dpkg |
| [CentOS](https://www.linuxprobe.com/) | .rpm        | yum                           |
| Fedora                                | .rpm        | dnf                           |
| FreeBSD                               | Ports, .txz | make, pkg                     |

##### 更新包列表

| **系统**         | **命令**                   |
| :--------------- | :------------------------- |
| Debian / Ubuntu  | sudo apt-get update        |
|                  | sudo apt update            |
| CentOS           | yum check-update           |
| Fedora           | dnf check-update           |
| FreeBSD Packages | sudo pkg update            |
| FreeBSD Ports    | sudo portsnap fetch update |

##### 更新已安装的包

| **系统**         | **命令**                                                     | **说明**                                                     |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Debian / Ubuntu  | sudo apt-get upgrade                                         | 只更新已安装的包                                             |
|                  | sudo apt-get dist-upgrade                                    | 可能会增加或删除包以满足新的依赖项                           |
|                  | sudo apt upgrade                                             | 和 apt-get upgrade 类似                                      |
|                  | sudo apt full-upgrade                                        | 和 apt-get dist-upgrade 类似                                 |
| CentOS           | sudo yum update                                              |                                                              |
| Fedora           | sudo dnf upgrade                                             |                                                              |
| FreeBSD Packages | sudo pkg upgrade                                             |                                                              |
| FreeBSD Ports    | less /usr/ports/UPDATING                                     | 使用 less 来查看 ports 的更新提示（使用上下光标键滚动，按 q 退出）。 |
|                  | cd /usr/ports/ports-mgmt/portmaster && sudo make install && sudo portmaster -a | 安装 portmaster 然后使用它更新已安装的 ports                 |

##### 搜索某个包

| 系统             | 命令                                           | 说明                             |
| :--------------- | :--------------------------------------------- | :------------------------------- |
| Debian / Ubuntu  | apt-cache search search_string                 |                                  |
|                  | apt search search_string                       |                                  |
| CentOS           | yum search search_string                       |                                  |
|                  | yum search all search_string                   | 搜索所有的字段，包括描述         |
| Fedora           | dnf search search_string                       |                                  |
|                  | dnf search all search_string                   | 搜索所有的字段，包括描述         |
| FreeBSD Packages | pkg search search_string                       | 通过名字进行搜索                 |
|                  | pkg search -f search_string                    | 通过名字进行搜索并返回完整的描述 |
|                  | pkg search -D search_string                    | 搜索描述                         |
| FreeBSD Ports    | cd /usr/ports && make search name=package      | 通过名字进行搜索                 |
|                  | cd /usr/ports && make search key=search_string | 搜索评论、描述和依赖             |

##### 查看某个软件包的信息

|                  |                                              |                          |
| :--------------- | :------------------------------------------- | :----------------------- |
| **系统**         | **命令**                                     | **说明**                 |
| Debian / Ubuntu  | apt-cache show package                       | 显示有关包的本地缓存信息 |
|                  | apt show package                             |                          |
|                  | dpkg -s package                              | 显示包的当前安装状态     |
| CentOS           | yum info package                             |                          |
|                  | yum deplist package                          | 列出包的依赖             |
| Fedora           | dnf info package                             |                          |
|                  | dnf repoquery --requires package             | 列出包的依赖             |
| FreeBSD Packages | pkg info package                             | 显示已安装的包的信息     |
| FreeBSD Ports    | cd /usr/ports/category/port && cat pkg-descr |                          |

##### 从存储库安装包

| **系统**         | **命令**                                         | **说明**                              |
| :--------------- | :----------------------------------------------- | :------------------------------------ |
| Debian / Ubuntu  | sudo apt-get install package                     |                                       |
|                  | sudo apt-get install package1 package2 ...       | 安装所有列出来的包                    |
|                  | sudo apt-get install -y package                  | 在 apt 提示是否继续的地方直接默认 yes |
|                  | sudo apt install package                         | 显示一个彩色的进度条                  |
| CentOS           | sudo yum install package                         |                                       |
|                  | sudo yum install package1 package2 ...           | 安装所有列出来的包                    |
|                  | sudo yum install -y package                      | 在 yum 提示是否继续的地方直接默认 yes |
| Fedora           | sudo dnf install package                         |                                       |
|                  | sudo dnf install package1 package2 ...           | 安装所有列出来的包                    |
|                  | sudo dnf install -y package                      | 在 dnf 提示是否继续的地方直接默认 yes |
| FreeBSD Packages | sudo pkg install package                         |                                       |
|                  | sudo pkg install package1 package2 ...           | 安装所有列出来的包                    |
| FreeBSD Ports    | cd /usr/ports/category/port && sudo make install | 从源码构建安装一个 port               |

##### 本地文件系统安装一个包

| **系统**         | **命令**                                                | **说明**                                                     |
| :--------------- | :------------------------------------------------------ | :----------------------------------------------------------- |
| Debian / Ubuntu  | sudo dpkg -i package.deb                                |                                                              |
|                  | sudo apt-get install -y gdebi && sudo gdebi package.deb | 安装 gdebi，然后使用 gdebi 安装 package.deb 并处理缺失的依赖 |
| CentOS           | sudo yum install package.rpm                            |                                                              |
| Fedora           | sudo dnf install package.rpm                            |                                                              |
| FreeBSD Packages | sudo pkg add package.txz                                |                                                              |
|                  | sudo pkg add -f package.txz                             | 即使已经安装的包也会重新安装                                 |

##### 删除一个或多个已安装的包

|                  |                                              |                |
| :--------------- | :------------------------------------------- | :------------- |
| 系统             | 命令                                         | 说明           |
|                  | sudo apt remove package                      |                |
|                  | sudo apt-get autoremove                      | 删除不需要的包 |
| CentOS           | sudo yum remove package                      |                |
| Fedora           | sudo dnf erase package                       |                |
| FreeBSD Packages | sudo pkg delete package                      |                |
|                  | sudo pkg autoremove                          | 删除不需要的包 |
| FreeBSD Ports    | sudo pkg delete package                      |                |
|                  | cd /usr/ports/path_to_port && make deinstall | 卸载 port      |

##### 获取帮助

| **系统**         | **命令**      | **说明**                                   |
| :--------------- | :------------ | :----------------------------------------- |
| Debian / Ubuntu  | man apt-get   | 更新本地包数据库以及与包一起工作           |
|                  | man apt-cache | 在本地的包数据库中搜索                     |
|                  | man dpkg      | 和单独的包文件一起工作以及能查询已安装的包 |
|                  | man apt       | 通过更简洁，用户友好的接口进行最基本的操作 |
| CentOS           | man yum       |                                            |
| Fedora           | man dnf       |                                            |
| FreeBSD Packages | man pkg       | 和预先编译的二进制包一起工作               |
| FreeBSD Ports    | man ports     | 和 Ports 集合一起工作                      |

