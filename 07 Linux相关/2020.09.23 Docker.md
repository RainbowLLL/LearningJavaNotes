## Docker

## 认识Docker

专业名词

- Image：镜像，封装好的应用和环境
- Container：容器，运行起来的镜像示例
- DockerHub：Docker 官方公有仓库
- Docker file：用来构建镜像的文本文件

查看linux系统内核版本`uname -r`

```shell
# 系统内核是3.10以上
[root@reanon ~]# uname -r
3.10.0-1127.18.2.el7.x86_64
```

查看当前系统的信息`cat /etc/os-release` 

```shell
[root@reanon ~]# cat /etc/os-release 
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"
CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
```

## 安装docker

阿里云:访问测试：39.97.76.165

密码：dfXXXxxx

参考[docker的官方文档](https://docs.docker.com/engine/install/centos/)

1. 卸载旧的版本

```shell
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

2. 需要的安装包

   ```shell
    yum install -y yum-utils
   ```

3. 设置镜像的仓库

   ```shell
   yum-config-manager \
       --add-repo \
       # 默认是国外的
       https://download.docker.com/linux/centos/docker-ce.repo
   
   # 安装阿里云的docker镜像仓库    
   yum-config-manager \
       --add-repo \
       http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
   ```

4. 安装docker的相关版本

   1. 安装Centos 7 版本

   ```shell
   # 更新软件包索引
   yum makecache fast
   
   # docker-ce社区版本 ee是企业版
   yum install docker-ce docker-ce-cli containerd.io
   ```

   2. 安装centos 8 版本

      - 首先安装 containerd.io；注意点：这里在官网直接安装会报错

        ```shell
        dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-17.03.3.ce-1.el7.x86_64.rpm
        ```

      - 安装完成之后，再安装剩下的两个

        ```shell
        dnf install docker-ce docker-ce-cli 
        ```

5. 启动并测试

   1. 这里需要启动docker的守护进程（也就是docker 引擎）之后才可以正常操作docker

   ```shell
   # 查看是否安装成功
   docker version
   
   # 启动docker
   systemctl start docker
   
   # 测试hello world
   docker run hello-world
   ```

   ![image-20200923201031452](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923201031.png)

   `docker run` 执行流程图

   ![image-20200923202844299](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923202844.png)

6. 查看下载的镜像

   ```shell
   [root@reanon ~]# docker images
   REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
   hello-world         latest              bf756fb1ae65        8 months ago        13.3kB
   ```

7. 卸载docker

   `/var/lib/docker`是默认工作路径

   ```shell
   # 卸载依赖
   yum remove docker-ce docker-ce-cli containerd.io
   # 删除资源：/var/lib/docker是默认工作路径
   rm -rf /var/lib/docker
   ```

### 阿里云镜像加速

1. 打开阿里云，控制台->产品与服务->容器镜像服务

![image-20200923201825207](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923201825.png)

2. 镜像加速器->找到加速器地址

![image-20200923202139529](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923202139.png)

3. 配置镜像加速器

   ```shell
   # 新建一个目录
   sudo mkdir -p /etc/docker
   # 配置一个地址
   sudo tee /etc/docker/daemon.json <<-'EOF'
   {
     "registry-mirrors": ["https://u96d4xx9.mirror.aliyuncs.com"]
   }
   EOF
   # 将镜像重启
   sudo systemctl daemon-reload
   # docker也重启
   sudo systemctl restart docker
   ```

### 底层原理

#### Docker是怎么运行的？

- Docker是一个Client - Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问。
- DockerServer接收到Docker-Client的指令，就会执行这个命令!
  ![image-20200923203408119](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923203408.png)

#### Docker为什么比虚拟机快？

1. Docker有着比虚拟机更少的抽象层。
2. docker利用的是宿主机的内核，vm需要是Guest OS。

![img](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923203529.png)

所以说，新建一个容器的时候，docker不需要想虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统吗，省略了这个复杂的过程，是属于秒级的

## Docker的常用命令

![image-20200928174533051](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201017153028.png)

帮助命令

```shell
# 显示docker版本信息
docker version
# 显示更加详细的docker系统信息，包括镜像和容器的数量
docker info
# 帮助命令
docker [命令] --help 
```

帮助文档的地址：[Reference documentation](https://docs.docker.com/reference/)

### 镜像命令

#### docker images  查看镜像

查看所有本地的主机上的镜像

```shell
[root@reanon ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        8 months ago        13.3kB

#解释
REPOSITORY 镜像的仓库源
TAG        镜像的标签
IMAGE ID   镜像的id
CREATED    镜像的创建时间
SIZE       镜像的大小

#可选项
-a，--a11    #列出所有镜像
-q，--quiet  #只显示镜像的id

# 示例
[root@reanon ~]# docker images -a
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        8 months ago        13.3kB
[root@reanon ~]# docker images -q
bf756fb1ae65
[root@reanon ~]# docker images -aq
bf756fb1ae65
```

#### docker search 搜索镜像

搜索镜像；也可以在[dockerHub](https://hub.docker.com/)上直接搜索一些常用的镜像。

```shell
[root@reanon ~]# docker search mysql
NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   9977                [OK]                
mariadb                           MariaDB is a community-developed fork of MyS…   3655                [OK]        
...

#可选项
--fi1ter             # 通过搜查来过滤.
--fi1ter=STARS=3000  # 搜索出来的镜像就是STARS大于3000
[root@reanon ~]# docker search mysql --filter=STARS=3000
NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
mysql               MySQL is a widely used, open-source relation…   9977                [OK]                
mariadb             MariaDB is a community-developed fork of MyS…   3655                [OK]

```

#### docker pull 下载镜像 

下载镜像  `docker pull 镜像名`

```shell
# docker pull 镜像名[:tag] 
# 不加tag默认是最新版
[root@reanon ~]# docker pull mysql
# 如果不写tag，默认就是latest(也即是最新版)
Using default tag: latest
latest: Pulling from library/mysql
# 分层下载，docker iamge的核心联合文件系统
d121f8d1c412: Pull complete 
f3cebc0b4691: Pull complete 
1862755a0b37: Pull complete 
489b44f3dbb4: Pull complete 
690874f836db: Pull complete 
baa8be383ffb: Pull complete 
55356608b4ac: Pull complete 
dd35ceccb6eb: Pull complete 
429b35712b19: Pull complete 
162d8291095c: Pull complete 
5e500ef7181b: Pull complete 
af7528e958b6: Pull complete 
# 签名
Digest: sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808
Status: Downloaded newer image for mysql:latest
# 真实地址
docker.io/library/mysql:latest
```

指定版本下载：`docker pull 镜像名 [:tag] `

`tag`需要是[dockerHub](https://hub.docker.com/_/mysql)中支持的镜像版本才行。

![image-20200923212323533](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200923212323.png)

```shell
[root@reanon ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
d121f8d1c412: Already exists 
f3cebc0b4691: Already exists 
1862755a0b37: Already exists 
489b44f3dbb4: Already exists 
690874f836db: Already exists 
baa8be383ffb: Already exists 
55356608b4ac: Already exists 
277d8f888368: Pull complete 
21f2da6feb67: Pull complete 
2c98f818bcb9: Pull complete 
031b0a770162: Pull complete 
Digest: sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7

# 查看当前镜像版本
[root@reanon ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mysql               5.7                 ef08065b0a30        13 days ago         448MB
mysql               latest              e1d7dc9731da        13 days ago         544MB
hello-world         latest              bf756fb1ae65        8 months ago        13.3kB

```

#### docker push 推送镜像

1. 登录dockerHub，就可以提交镜像了。

   ```shell
   root@reanon tomcat]# docker login -u reanon
   Password: 
   WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
   Configure a credential helper to remove this warning. See
   https://docs.docker.com/engine/reference/commandline/login/#credentials-store
   
   Login Succeeded
   [root@reanon tomcat]# 
   ```


2. 发布镜像，尽量带上版本号（也即是tag)    

```shell
# push 镜像到服务器上
[root@kuangshen tomcat]# docker push reanon/diytomcat:1.0
The push refers to repository [docker.io/library/diytomcat]
fcc7fccb8e04: Preparing
...
# push 镜像出问题
The push refers to repository [docker.io/kuangshen/diytomcat2]
An image does not exist locally with the tag: kuangshen/diytomcat2
# 解决，增加一个tag
[root@kuangshen tomcat]# docker tag f8559daf1fc2 reanon/diytomcat:1.0
```

发布到阿里云

1. 登录阿里云

2. 找到容器镜像服务

3. 创建命名空间

   ![](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928173803.png)

4. 创建容器镜像

   ![image-20200928173945660](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928173945.png)

5. 查看基本信息

   点击仓库名称

   ![image-20200928174049157](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928174049.png)

#### docker tag 增加标签

- 给镜像增加一个标签：`docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]`

  ```shell
  [root@kuangshen tomcat]# docker tag f8559daf1fc2 kuangshen/tomcat:1.0
  ```

#### docker rmi 删除镜像

通过IMAGE ID 删除容器：`docker rmi -f [镜像ID]`

- 删除多个容器：`docker rmi -f [镜像ID] [镜像IID] [镜像IID]`

```shell
# 通过IMAGE ID 删除镜像
[root@reanon ~]# docker rmi -f ef08065b0a30
Untagged: mysql:5.7
Untagged: mysql@sha256:14fd47ec8724954b63d1a236d2299b8da25c9bbb8eacc739bb88038d82da4919
...
Deleted: sha256:aded9a11fc54761c770a9075cfc2d0bb72c72b59171a56cfa4322ab2b2d416e7
```

可以给调用参数删除：`docker rmi -f $()`

- 递归删除全部的容器：`docker rmi -f $(docker images -aq)`

```shell
[root@reanon ~]# docker rmi -f $(docker images -aq)
Untagged: mysql:latest
Untagged: mysql@sha256:e1bfe11693ed2052cb3b4e5fa356c65381129e87e38551c6cd6ec532ebe0e808
...
Untagged: hello-world:latest
Untagged: hello-world@sha256:4cf9c47f86df71d48364001ede3a4fcd85ae80ce02ebad74156906caff5378bc
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b

# 查看此时的镜像
[root@reanon ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
```

#### docker save 导出镜像

- 导出镜像：`docker save -o filename.tar TARGET_IMAGE[:TAG]`
  - -o：

#### docker load 导入镜像

- 导入镜像：`docker load –i filename.tar`

#### docker build 构建文件

docker build 构建文件：`docker build -f [dockerfile文件路径] -t [镜像]:[tag] .`

1. -f：指定dockerfile文件
2. -t ：指定生成的目标镜像
3. `.` ：在当期目录下生成，不能忘记

```shell
# 开始构建镜像
[root@reanon dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .
Sending build context to Docker daemon  2.048kB
Step 1/10 : FROM centos
 ---> 0d120b6ccaa8
Step 2/10 : MAINTAINER reanon<>
...

Removing intermediate container 451e44668286
 ---> a1456f2704a1
Successfully built a1456f2704a1
Successfully tagged mycentos:0.1
```

### 容器命令

说明∶我们有了镜像才可以创建容器`linux`，下载一个centos镜像来测试学习

```shell
docker pull centos
```

#### docker ps 列出容器

- 当前正在运行的容器：`docker ps`
- 曾经运行过的：`docker ps -a`
- 列出运行过的容器的id：`docker ps -aq`
- 显示最近运行过的容器的id：`docker ps -n=1 -q`

```shell
# docker ps 
		# 列出当前正在运行的容器
-a       # 列出当前正在运行的容器+带出历史运行过的容器 
-n=?     # 显示最近创建的容器，?指代的是个数
-q 		# 只显示容器编号,一般需要联合起来使用
-l       # 显示最后运行的容器
```

测试一下

```shell
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@reanon ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
a7a792f176c6        centos              "/bin/bash"         18 minutes ago      Exited (0) 18 minutes ago                       confident_murdock
9fb167404e75        bf756fb1ae65        "/hello"            13 hours ago        Exited (0) 13 hours ago                         gallant_beaver
[root@reanon ~]# docker ps -n=1
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
a7a792f176c6        centos              "/bin/bash"         18 minutes ago      Exited (0) 18 minutes ago                       confident_murdock

```



#### docker run 生成容器

- 新建容器并启动：`docker run [可选参数] 镜像id|镜像名[:tag]`
- 后台启动容器：`docker run -d 镜像id|镜像名[:tag]`

```shell
docker run [可选参数] image

# 参数说明
-name ="Name" 	容器名字tomcato1,tomcat02，用来区分容器
-d			   后台方式运行      
-it 		   使用交互方式运行，进入容器查看内容
-p              指定容器的端口-p 8080:8080
	-p          ip:主机端口:容器端
	-p          主机端口:容器端口（常用）
	-p          容器端口
-P              随机端口
```

测试一下

- 进入centos容器：`docker run -it centos /bin/bash`
- 从容器中退出主机：`exit`

```shell
[root@reanon ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              latest              0d120b6ccaa8        6 weeks ago         215MB

# 测试，启动并进入容器
[root@reanon ~]# docker run -it centos /bin/bash

# 查看容器内的centos，基础版本，很多命令都是不完善的!
[root@a7a792f176c6 /]# ls  
bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr

[root@a7a792f176c6 /]# exit
exit
[root@reanon ~]# 
```

后台启动容器

- 问题docker ps，发现centos停止了
- 常见的坑: docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止
- nginx，容器启动后，发现自己没有提供服务，就会立刻停止，没有程序了

```shell
# 后台启动容器centos
[root@reanon ~]# docker run -d centos
e6d20c4087337f6d69f81fa6d562960de516a2adf27eee68621e8430c922bc79
# 查看当前运行的容器，发现没有容器在运行
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

#### docker exec  进入容器

- 进入容器后开启一个新的终端，可以在里面操作：`docker exec -it [容器id]`
- 执行正在后台运行的容器：`docker exec -i -t [容器名/id] /bin/bash`
- 这种方式使用`exit`退出后，依然会在后台运行

```python
## 方式一 进入容器
# 当前没有容器在运行
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

# 以交互方式运行一个容器，/bin/bash 算是一个参数，这里不深究
[root@reanon ~]# docker run -it centos /bin/bash

# ctrl + p + q退出
[root@5c92b1bc5859 /]# [root@reanon ~]# 

# 有容器正在开始运行
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
5c92b1bc5859        centos              "/bin/bash"         38 seconds ago      Up 37 seconds                           great_moore

# 未带/bin/bash 会报错
[root@reanon ~]# docker exec -it 5c92b1bc5859
"docker exec" requires at least 2 arguments.
See 'docker exec --help'.
Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
Run a command in a running container

# 进入后台容器
[root@reanon ~]# docker exec -it 5c92b1bc5859 /bin/bash
# 退出容器
[root@5c92b1bc5859 /]# exit
```

#### docker attach 

- 进入容器正在执行的终端，不会启动新的进程：`docker attach [容器id]`
- 使用`exit`退出后，容器就停止运行了。

```shell
## 方式二 进入容器
# 进入容器
[root@reanon ~]# docker attach  5c92b1bc5859
[root@5c92b1bc5859 /]# 
```

#### exit 退出容器

- 容器停止并退出容器：`exit`
- 容器退出不停止：`Ctrl + P + Q`

```shell
# 当前无容器在运行
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@reanon ~]# docker run -it centos /bin/bash
# Ctrl + P + Q 退出
# 查看当前正在运行的容器
[root@924d2b82447e /]# [root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
924d2b82447e        centos              "/bin/bash"         19 seconds ago      Up 18 seconds                           gracious_yalow
```

#### docker rm 删除容器

-  删除指定容器：`docker rm [容器id]`
- 强制删除正在运行的容器：`docker rm -f  [容器id]`
- 删除所有容器：`docker rm -f $(docker ps -aq)`
-  通过管道删除所有容器：`docker ps -a -q|xargs docker rm`
   - `xargs` 是一个参数

```shell
# 查看所有容器
[root@reanon ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
924d2b82447e        centos              "/bin/bash"         4 minutes ago       Up 4 minutes                                    gracious_ya
a7a792f176c6        centos              "/bin/bash"         24 minutes ago      Exited (0) 24 minutes ago                       confident_m
9fb167404e75        bf756fb1ae65        "/hello"            13 hours ago        Exited (0) 13 hours ago                         gallant_bea
# 删除停止运行的容器
[root@reanon ~]# docker rm a7a792f176c6
a7a792f176c6

# 不能删除正在运行的容器
[root@reanon ~]# docker rm 924d2b82447e
Error response from daemon: You cannot remove a running container 924d2b82447e2cf9f972f5528306a3c6763037e2fefbbf918fb728375877399d. Stop the container before attempting removal or force remove

# 强制删除
[root@reanon ~]# docker rm -f  924d2b82447e
924d2b82447e

# 查看所有容器的id
[root@reanon ~]# docker ps -aq
9fb167404e75

# 删除所有容器
[root@reanon ~]# docker rm -f $(docker ps -aq)
9fb167404e75
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

```

#### docker start  启动容器

- 启动容器：`docker start [容器id]`
- 重启容器：`docker restart [容器id]`

```shell
# 查看当前运行程序
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
# 查看历史运行过的容器
[root@reanon ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
5f0d250e33b1        centos              "/bin/bash"         9 minutes ago       Exited (0) 9 minutes ago                       elegant_gagarin
# 启动容器，使用容器id(CONTAINER ID)
[root@reanon ~]# docker start 5f0d250e33b1
5f0d250e33b1
# 查看当前运行的容器，发现启动成功
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
5f0d250e33b1        centos              "/bin/bash"         9 minutes ago       Up 8 seconds                            elegant_gagarin
```

#### docker stop 停止容器

- 停止当前正在运行的容器：`docker stop [容器id]`
- 强制停止当前容器：`docker kill [容器id]`

```shell
# 关闭运行的容器
[root@reanon ~]# docker stop 5f0d250e33b1
5f0d250e33b1

# 查看当前运行的容器，发现关闭成功
[root@reanon ~]# docker ps 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

#### docker commit 提交镜像

- 提交容器成为一个新的镜像：`docker commit -m="提交的描述信息"  -a="作者" 容器id 目标镜像名:TAG`
  - -a：作者
  - -m：提交的描述信息
  - -c：使用Dockerfile来创建镜像
  - -p：在commit时，将容器暂停

```shell
# 启动一个默认的tomcat
[root@reanon ~]# docker run tomca
[root@reanon ~]# docker exec -it 4a9607a28239 /bin/bash
root@4a9607a28239:/usr/local/tomcat#

# 发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认 webapps下面是没有文件的!
root@4a9607a28239:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

# 自己拷贝进去了基本的文件
root@4a9607a28239:/usr/local/tomcat# cp -r webapps.dist/* webapps/
root@4a9607a28239:/usr/local/tomcat# cd webapps
root@4a9607a28239:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
```

将我们操作过的容器通过commit提交为一个镜像

```shell
# 提交镜像
[root@reanon ~]# docker commit -a="reanon" -m="add webapps" 4a9607a28239 tomcat02:1.0
sha256:60482ed5972a2a21066500a558e1ec47e5c7162ee6085152ae8084a034a10d6d
# 查看镜像
[root@reanon ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
tomcat02              1.0                 60482ed5972a        30 seconds ago      652MB
...
```

### 常用的其他命令

#### docker logs 查看日志 

- 显示容器后十条的日志信息：`docker logs -t -f --tail 10 [容器id]`

```shell
# docker logs
-t       # 显示时间戳
-f       # 显示日志的格式
	--tail [条数] # 显示日志要显示的条数 
```

#### docker top 查看进程

- 查看容器中的进程：docker top `[容器id]`

#### docker inspect 查看镜像元数据

```shell
[root@reanon ~]# docker inspect e6d20c408733
```

#### docker cp  拷贝文件

- 从容器内部拷贝文件到主机上：`docker cp [容器id]:[容器内路径]  目的主机路径`
- 拷贝是一个手动过程，未来我们使用 `-v` 卷的技术，可以实现，自动同步

```shell
# docker cp 5c92b1bc5859:/home/test.java /home
# 进入容器
[root@reanon ~]# docker attach  5c92b1bc5859
# 在容器的/home目录下新建一个文件
[root@5c92b1bc5859 /]# cd home
[root@5c92b1bc5859 home]# ls
[root@5c92b1bc5859 home]# touch test.java
[root@5c92b1bc5859 home]# ls
test.java
# 退出容器
[root@5c92b1bc5859 home]# exit
exit
# 返回主机
[root@reanon ~]# cd /home
[root@reanon home]# ls

# 将容器内文件拷贝到当前主机
[root@reanon home]# docker cp 5c92b1bc5859:/home/test.java /home
# 测试成功
[root@reanon home]# ls
test.java

```

#### docker volume 查看卷

所有的docker容器内的卷，没有指定目录的情况下都是在
`/var/lib/docker/voltmes/xxxx`/_data

- 显示全部挂载：`docker volume ls`
- 查看卷的具体位置：`docker volume inspect [相对具名]`

```shell
# 查看一下这个卷
[root@reanon home]# docker volume inspect juming-ngnix
[
    {
        "CreatedAt": "2020-09-26T20:55:11+08:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming-ngnix/_data",
        "Name": "juming-ngnix",
        "Options": null,
        "Scope": "local"
    }
]
```



#### docker stats 查看资源

#### docker history 查看镜像构建历史

- docker history [镜像id]

```shell
[root@reanon dockerfile]# docker history a1456f2704a1
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
a1456f2704a1        13 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "/bin…   0B   
14d50190f34a        13 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B   
1b92195fef37        13 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B   
4ce0a4f2bb11        13 minutes ago      /bin/sh -c #(nop)  EXPOSE 80                    0B   
1dd122811db9        13 minutes ago      /bin/sh -c yum -y install net-tools             22.8MB              
216d27d11455        13 minutes ago      /bin/sh -c yum -y install vim                   57.2MB              
cc96cbd7ea10        13 minutes ago      /bin/sh -c #(nop) WORKDIR /usr/local            0B   
f673616769c7        13 minutes ago      /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B   
7dd0217de256        13 minutes ago      /bin/sh -c #(nop)  MAINTAINER reanon<>          0B   
0d120b6ccaa8        6 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B  
<missing>           6 weeks ago         /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B   
<missing>           6 weeks ago         /bin/sh -c #(nop) ADD file:538afc0c5c964ce0d…   215MB 
```



#### docker network

- 列出所有网络：`docker network ls` 
- 删除一个网络：`docker network rm + [网络]` 
- 创建一个网卡：`docker network create --driver bridge --subnet [网络] --gateway [网关] mynet`
  - 指定桥接模式：--driver bridg
  - 设定子网：`--subnet 192.168.0.0/16`
  - 设定网关：`--gateway 192.168.0.1`
- 查看网络配置：`docker network inspect [网络名]`\
- 连接一个网络：`docker network connect [OPTIONS] NETWORK CONTAINER` 
  - --alias strings           Add network-scoped alias for the container
  - --driver-opt strings      driver options for the network
  - --ip string               IPv4 address (e.g., 172.30.100.104)
  -  --ip6 string              IPv6 address (e.g., 2001:db8::33)
  - --link list               Add link to another container
  -  --link-local-ip strings   Add a link-local address for the container

### 命令小结

![image-20200924220014376](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200924220014.png)

## Docker 实验室使用

### 第一次登入服务器

1. 创建镜像（pull/load）

2. 实例化镜像，生成容器

3. 进入容器（attach/exec），配置环境

4. 退出容器，记录自己的容器Id

5. 断开服务器连接

### 第二次登入服务器

1. 进入容器(attach/exec)，继续工作
2. 退出容器
3. 断开服务器连接

## Docker 使用示例

### 部署Nginx

在[dockerHub](https://hub.docker.com/search?q=Nginx&type=image) 上搜索Nginx 

![image-20200924220534657](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200924220534.png)

#### 1.搜索镜像

```shell
[root@reanon home]# docker search nginx
NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
nginx                              Official build of Nginx.                        13771               [OK]                
...
wodby/nginx                        Generic nginx                                   1                                       [OK]
ansibleplaybookbundle/nginx-apb    An APB to deploy NGINX  
```

#### 2.下载镜像

```shell 
# 拉取镜像
[root@reanon home]# docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
...
2ee525c5c3cc: Pull complete 
Digest: sha256:c628b67d21744fce822d22fdcc0389f6bd763daac23a6b77147d0712ea7102d0
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest

# 查看镜像
[root@reanon home]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              7e4d58f0e5f3        2 weeks ago         133MB
centos              latest              0d120b6ccaa8        6 weeks ago         215MB
```

#### 3、端口映射

- 运行：`docker run -d --name ngnix01 -p 3344:80 nginx`
  -  -p [宿主机端口]:[容器内部端口]
- 测试主机上的端口：`curl [ip or localhost]:[端口号]`

```shell
# -d  后台运行
# --name给容器命名
# -p 宿主机端口:容器内部端口
[root@reanon ~]# docker run -d --name ngnix01 -p 3344:80 nginx
2fa771dce3f845dc4571bcad4767e3549f5605e4fdc56352eb0ceecc65f993c3
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
2fa771dce3f8        nginx               "/docker-entrypoint.…"   15 seconds ago      Up 15 seconds       0.0.0.0:3344->80/tcp   ngnix01

# 访问本地端口
[root@reanon ~]# curl localhost:3344
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...
<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

![image-20200926154318456](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926154325.png)

#### 4、进入容器

- 执行正在后台运行的容器：`docker exec -i -t [容器名/id] /bin/bash`
- 查看配置目录：`whereis nginx`

```shell
# 执行
[root@reanon ~]# docker exec -i -t ngnix01 /bin/bash
# 查找
root@2fa771dce3f8:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@2fa771dce3f8:/# cd /etc/nginx/

# 使用不了ll 
root@2fa771dce3f8:/etc/nginx# ll
bash: ll: command not found

root@2fa771dce3f8:/etc/nginx# ls
conf.d		koi-utf  mime.types  nginx.conf   uwsgi_params
fastcgi_params	koi-win  modules     scgi_params  win-utf

```

### 部署Tomcat

- 官方的使用： `docker run -it --rm tomcat:9.0`
- 我们之前的启动都是后台，停止了容器之后，容器还是可以查到。用完即删除容器：`docker run -it --rm`； 一般用来测试。
- 正常下载：`docker pull tomcat:9.0`
- 启动运行：`docker run -d -p 3355:8080 --name tomcat01 tomcat` 
- 进入容器：`docker exec -it tomcat01 /bin/bash`

发现问题:1、linux命令少了；2、没有webapps。阿里云镜像的原因：默认是最小的镜像，所有不必要的都剔除掉。
保证最小可运行的环境!

思考问题:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外部提供一个映射路径，webapps ，我们在外部放置项目，就自动同步到内部就好了!

### 部署ES+Kibana

- 问题
  - es暴露的端口很多!
  - es十分的耗内存
  - es的数据—般需要放置(挂载)到安全目录! 
- 官方推荐：`docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag`
  - --net somenetwork 网络配置，这里不用
  - `-e "discovery.type=single-node"` 配置环境
  - `-e ES_JAVA_OPTS="-Xms64m -Xmx512m"` ：内存配置；最低64M，最高512M内存
- 查看端口：`curl localhost:9200`
- 查看资源使用情况：`docker stats`
- 停止一个容器：`docker stop [容器id]`

```shell
# 启动 elasticsearch
docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2
# 启动了elasticsearch之后会很卡，因为它很耗内存

# 测试是否成功
[root@reanon ~]# curl localhost:9200
{
  "name" : "97436007c815",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "BAeI-EFPQ2-ZqonHBO__Pw",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
# 查看内存使用情况
[root@reanon ~]# docker stats
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
97436007c815        elasticsearch       0.51%               1.233GiB / 1.795GiB   68.68%              656B / 0B           241MB / 729kB       41
2fa771dce3f8        ngnix01             0.00%               1.422MiB / 1.795GiB   0.08%               1.29kB / 1.27kB     0B / 4.1kB 
```

#### 增加内存限制

修改配置文件，`-e` 环境配置修改

- 最低64M，最高512M内存：`-e ES_JAVA_OPTS="-Xms64m -Xmx512m"` 

```shell
# 运行容器，限制内存占用
[root@reanon ~] docker run -d --name elasticsearch02  -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2

# 查看资源使用
[root@reanon ~]# docker stats
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
f6eda91ca293        elasticsearch02     0.32%               354.1MiB / 1.795GiB   19.26%              656B / 0B           100MB / 729kB       42

# 测试
[root@reanon ~]# curl localhost:9200
{
  "name" : "f6eda91ca293",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "GaJRVFNKReOBqk8TTaa5PQ",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```

思考：网络如里才能连接过去，使kibana连接es?

![image-20200926163648790](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926163648.png)

### 可视化

#### portainer

Docker图形化界面管理工具，提供一个后台面板供我们操作!

- 访问测试：主机ip:主机端口（例如 在浏览器中输入：39.97.76.165:8080）

```shell
# -v 挂载
docker run -d -p 8080:9000 \
--name=portainer01 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
# 访问测试 
[root@reanon ~]# curl localhost:8080
<!DOCTYPE html
><html lang="en" ng-app="portainer">
  <head>
...
  <script type="text/javascript" src="vendor.bd742767a7e5e3fe6f78.js"></script><script type="text/javascript" src="main.bd742767a7e5e3fe6f78.js"></script></body></html
>
```

在浏览器中输入 39.97.76.165:8080

![image-20200926171035281](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926171035.png)

选择local

![image-20200926171115522](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926171115.png)

#### Rancher(CI/CD再用)

### 部署Redis集群

![image-20200929095933322](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929095933.png)



```shell
# 清理环境，删除所有镜像
[root@reanon ~]# docker rm -f $(docker ps -a -q)
cfe090977fe8
...
295346314e14

# 创建一个网卡
[root@reanon ~]# docker network create redis --subnet 172.38.0.0/16
ff16071ace5faf2ed9573c0769bfe0aa116b46523d10614dd5ca41932e15f9e0
# 查看网卡
[root@reanon ~]# docker network  inspect redis
[
...
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.38.0.0/16"
                }
...
]

```

通过脚本创建redis 配置

```shell
#通过脚本创建六个redis配置
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-${port}/conf
touch /mydata/redis/node-${port}/conf/redis.conf
cat << EOF >/mydata/redis/node-${port}/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enab1ed yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done
```

执行脚本，发现创建成功

```shell
# 直接复制，然后执行
[root@reanon ~]# for port in $(seq 1 6);\
> do \
> mkdir -p /mydata/redis/node-${port}/conf
> touch /mydata/redis/node-${port}/conf/redis.conf
> cat << EOF >/mydata/redis/node-${port}/conf/redis.conf
> port 6379
> bind 0.0.0.0
> cluster-enab1ed yes
> cluster-config-file nodes.conf
> cluster-node-timeout 5000
> cluster-announce-ip 172.38.0.1${port}
> cluster-announce-port 6379
> cluster-announce-bus-port 16379
> appendonly yes
> EOF
> done

# 查看六个节点是否创建成功
[root@reanon /]# ls /mydata/redis/
node-1  node-2  node-3  node-4  node-5  node-6

# 查看配置文件是否正确创建
[root@reanon /]# cat /mydata/redis/node-1/conf/redis.conf 
port 6379
bind 0.0.0.0
cluster-enab1ed yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.11
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes

```

启动容器

- 指定端口：-p [宿主机端口]:[容器内端口]
- 指定容器名：--name [容器名]
- 后台运行：-d
- 指定网络：--net [网络名]
- 绑定ip：--ip [172.38.0.11]
- 指定镜像：[镜像]：[tag]
- 启动执行容器命令（启动redis)：`redis-server /etc/redis/redis.conf`

```shell
docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port}\
-v /mydata/redis/node-${port}/data:/data \
-v /mydata/redis/node-${port} /conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf;

# 启动容器1
docker run -p 6371:6379 -p 16371:16379 --name redis-1 \
-v /mydata/redis/node-1/data:/data \
-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

# 启动容器2:修改端口、容器名、本地的文件名、指定的ip
docker run -p 6372:6379 -p 16372:16379 --name redis-2 \
-v /mydata/redis/node-2/data:/data \
-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
```

#### 执行容器脚本

```shell
# 启动容器1
[root@reanon /]# docker run -p 6371:6379 -p 16371:16379 --name redis-1 \
> -v /mydata/redis/node-1/data:/data \
> -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \
> -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

Unable to find image 'redis:5.0.9-alpine3.11' locally
5.0.9-alpine3.11: Pulling from library/redis
...
a2c652551612: Pull complete 
Digest: sha256:83a3af36d5e57f2901b4783c313720e5fa3ecf0424ba86ad9775e06a9a5e35d0
Status: Downloaded newer image for redis:5.0.9-alpine3.11
562492bdcde5b56f70f47cab7d8234e24f3efc02bb37f3dbbcab22081ea3389b

# # 启动容器2
[root@reanon /]# docker run -p 6372:6379 -p 16372:16379 --name redis-2 \
> -v /mydata/redis/node-2/data:/data \
> -v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \
> -d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
5a5704777552a32b976c5fcfae16c4c57dd8522bb423557fa535db4cce6b9765

# 查看配置文件是否正确创建
[root@reanon /]# cat /mydata/redis/node-1/conf/redis.conf 
port 6379
bind 0.0.0.0
cluster-enab1ed yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.11
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes

```

这里布置起来并不完全，需要重新学习一下。



### SpringBoot微服务打包Docker镜像

1、构架springboot项目
2、打包应用
3、编写dockerfile
4、构建镜像
5、发布运行

一般只发布Dockerfile文件和jar包

```dockerfile
FROM java:8
COPY *.jar /app.jar
CMD["--server.port=8080"]
EXPOSE 8080
ENTRYPOINT ["java" , "-jar" , " /app.jar"]
```

打包

![image-20200929113819839](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929113820.png)

## Docker镜像

### 镜像是什么

镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。

所有的应用，直接打包docker镜像，就可以直接跑起来!
如何得到镜像:

- 从远程仓库下载
- 朋友拷贝给你
- 自己制作一个镜像Dockerl

### Docker镜像加载原理

#### UnionFS(联合文件系统）

UnionFS(联合文件系统）: Union文件系统(UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

特性∶一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。

#### Docker镜像加载原理

docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS(联合文件系统）。

![image-20200926173506077](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926173635.png)

**bootfs(boot file system，引导文件系统)**主要包含bootloader（加载器）和kernel（内核）。

- bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统
- 在Docker镜像的最底层是bootfs。
- 这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。

**rootfs (root file system)**，在bootfs之上。

- 包含的就是典型Linux系统中的/dev、/proc、/bin、/etc等标准目录和文件。
- roots就是各种不同的操作系统发行版，比如Ubuntu, Centos等等。

对于一个精简的OS，rootfs可以很小，只需要包含**最基本的命令**，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别，因此不同的发行版可以公用bootfs。

### 分层的理解

#### 分层的镜像

- 查看镜像分层的方式可以通过 `docker image inspect [镜像名]:[tag]`  命令

我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载。

![image-20200926174112135](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926174112.png)

思考:为什么Docker镜像要采用这种分层的结构呢?
最大的好处，莫过于是资源共享了，比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享

查看有几层：`docker image inspect redis:latest`

```shell
# 查看层级结构
[root@reanon ~]# docker image inspect redis:latest
[
	//....
	        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:07cab433985205f29909739f511777a810f4a9aff486355b71308bb654cdc868",
                "sha256:45b5e221b6729773b50b4fc89e83a623f9f63ddf37e37078d5f197811db6177d",
                "sha256:7fb1fa4d4022ba2387d0df7820fa41c797eeda6f1192920da8cb99c6475dd9d1",
                "sha256:47d8fadc671445422662d5a25e09b2fabd2a77c7da4338ab3f817592fd60c84b",
                "sha256:ea96cbf71ac4d770813f8fd209a20ddb3b81c69992be2c0c3e1d1a4b9fb0da1a",
                "sha256:2e9c060aef92b6b958bee61fbf5f239443c629e6a62f1103c3ada7deb10aa543"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

#### 理解

所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。
举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。

![image-20200926174828961](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926174829.png)

在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。

![image-20200926174936331](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926174936.png)

上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。
下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。

![image-20200926175121294](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926175121.png)

这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。
Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。
Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的 文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。
Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW[1]。
下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。

#### 特点

Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。
这一层就是我们通常说的容器层，容器之下的都叫镜像层。

![image-20200926175432078](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926175432.png)

Commit镜像

- 提交容器成为一个新的副本：`docker commit -m="提交的描述信息"  -a="作者" 容器id 目标镜像名:TAG`
  - -a：作者
  - -m：提交的描述信息
  - -c：使用Dockerfile来创建镜像
  - -p：在commit时，将容器暂停

```shell
# 启动一个默认的tomcat
[root@reanon ~]# docker run tomca
[root@reanon ~]# docker exec -it 4a9607a28239 /bin/bash
root@4a9607a28239:/usr/local/tomcat#

# 发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认 webapps下面是没有文件的!
root@4a9607a28239:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

# 自己拷贝进去了基本的文件
root@4a9607a28239:/usr/local/tomcat# cp -r webapps.dist/* webapps/
root@4a9607a28239:/usr/local/tomcat# cd webapps
root@4a9607a28239:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
```

将我们操作过的容器通过commit提交为一个镜像

```shell
# 提交镜像
[root@reanon ~]# docker commit -a="reanon" -m="add webapps" 4a9607a28239 tomcat02:1.0
sha256:60482ed5972a2a21066500a558e1ec47e5c7162ee6085152ae8084a034a10d6d
# 查看镜像
[root@reanon ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
tomcat02              1.0                 60482ed5972a        30 seconds ago      652MB
...
```

## 容器数据卷

### 什么是容器数据卷

docker就是将应用和环境打包成一个镜像；容器数据卷也就是容器的持久化和同步操作，使得容器间也是可以数据共享的!

- MySQL数据可以存储在本地：
  - 如果数据都在容器中，那么我们容器删除，数据就会丢失!
- 数据可以持久化
  - MySQL容器删了，删库跑路，容器之间可以有一个数据共享的技术!
  - Docker容器中产生的数据，同步到本地
- 卷技术：也就是目录的挂载，将我们容器内的目录挂载到Linux上面!

![image-20200926193646928](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926193647.png)



### 使用数据卷

- 使用命令来挂载-v：`docker run -it -v [主机目录]:[容器内目录]  [镜像名] [命令行]`
- 查看容器是否挂载成功：`docker inspect [容器id]`
- 再次进入容器：`docker exec -it [容器id] /bin/bash`
- 进入正在运行的容器：`docker attach [容器id]`

```shell
# 开始挂载
[root@reanon ~]# docker run -it -v /home/ceshi:/home centos /bin/bash
[root@5fee9608c6c4 /]# ll

# 查看docker 信息
[root@reanon ~]# docker inspect 5fee9608c6c4
```

![image-20200926195112652](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926195112.png)

```shell
# 再次进入容器
[root@reanon ~]# docker exec -it 5fee9608c6c4 /bin/bash
[root@5fee9608c6c4 /]#

# 在目录下新建一个文件
[root@5fee9608c6c4 home]# touch test.java

# 回到主机下，发现映射的/home/ceshi下也出现了文件
[root@reanon ceshi]# ls
test.java
```

![image-20200926195816246](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926195816.png)

再次测试：

1. 停止容器
2. 宿主机上修改文件
3. 启动容器
4. 容器内的数据依旧是同步的!

![image-20200926200405813](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926200405.png)

好处：我们以后修改只需要在本地修改即可，容器内会自动同步!

### 部署MySQL

- 拉取镜像：`docker pull mysql:5.7`
- 官方启动：`docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag`
  - 指定容器名： `--name some-mysql`
  - 数据卷挂载配置文件：`-v /my/custom:/etc/mysql/conf.d`
  - 数据卷挂载数据文件：`-v /home/mysql/data:/var/lib/mysql`
  - 指定映射端口：`-p 3310:3306`
  - 后台运行：`run -d`
  - 指定密码：`-e  MYSQL_ROOT_PASSWORD=123`

```shell
# 拉取镜像
[root@reanon ceshi]# docker pull mysql:5.7
# 启动镜像
[root@reanon /]# docker run -d -p 3310:3306 --name mysql01 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e  MYSQL_ROOT_PASSWORD=123 mysql:5.7
d4193ad31da9ffc645d23d934b333f7fee7a5cc2fc3f2ed36d14513ac4b5ff0b

# 启动成功之后，我们在本地使用sqlyog来接测试一下
# sqlyog-连接到服务器的3310 --- 3310 和容器内的3306映射，这个时候我们就可以连接上了!

```

![image-20200926203220450](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926203220.png)

假设我们将容器删除，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能!

### 具名和匿名挂载

- 匿名挂载：`-v [容器内路径]` 
  - 挂载位置在`/var/lib/docker/voltmes/xxxx/_data`下，其中xxx是一串字符串的卷名
- 相对路径具名挂载：`-[卷名]:[容器内路径]` 
  - 挂载位置在`/var/lib/docker/voltmes/[卷名]/_data`下
- 指定路径挂载：`-v /[宿主机路径]:[容器内路径]` 
  - 指定路径以斜杠`/`开头 
- 改变容器的读写权限：`-v xxxx:[容器内路径]:ro / rw`
  - 只读ro：readonly；如`docker run -d -P --name nginx01 -v /etc/nginx nginx`
  - 可读可写rw：readwrite

##### 匿名挂载

- `docker run -d -P --name nginx01 -v /etc/nginx nginx`
- 随机端口映射：`-P`
- 匿名挂载：`-v [容器内路径]`
- 查看所有的volume的情况：`docker volume ls`

```shell
# 查看所有的volume的情况
[root@reanon data]#  docker volume ls
DRIVER              VOLUME NAME
local               779a156e2a4212778ce3cae3078c35896a24935dcf8bb8164f625c398fd1a071
local               fd38b9ed30ad9b5e9f9d05db75c9ecaa63e055eb1b34c170961bd03842f86c41
# 这里发现，这种就是匿名挂载，我们在-v只写了容器内的路径，没有写容器外的路径
```

##### 具名挂载

- `docker run -d -P --name nginx02 -v juming-ngnix:/etc/nginx nginx`

- 相对路径映射：`-v juming-ngnix:/etc/nginx`
- 查看映射的位置：`docker volume inspect [相对具名]`
- 绝对路径映射：`-v /home/juming-ngnix:/etc/nginx`

```shell
# 查看所有的volume的情况
[root@reanon home]# docker volume ls
```

![image-20200926205638324](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926205638.png)

```shell 
# 查看一下这个卷
[root@reanon home]# docker volume inspect juming-ngnix
[
    {
        "CreatedAt": "2020-09-26T20:55:11+08:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming-ngnix/_data",
        "Name": "juming-ngnix",
        "Options": null,
        "Scope": "local"
    }
]
```

所有的docker容器内的卷，没有指定目录的情况下都是在
`/var/lib/docker/voltmes/xxxx/_data`；我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的“具名挂载”

```shell
[root@reanon home]# cd /var/lib/docker/
[root@reanon docker]# ls
builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes
[root@reanon docker]# cd volumes/
[root@reanon volumes]# ls
779a156e2a4212778ce3cae3078c35896a24935dcf8bb8164f625c398fd1a071  juming-ngnix
fd38b9ed30ad9b5e9f9d05db75c9ecaa63e055eb1b34c170961bd03842f86c41  metadata.db
[root@reanon volumes]# cd juming-ngnix/
[root@reanon juming-ngnix]# ls
_data
[root@reanon juming-ngnix]# cd _data/
[root@reanon _data]# ls
conf.d          koi-utf  mime.types  nginx.conf   uwsgi_params
fastcgi_params  koi-win  modules     scgi_params  win-utf
```

##### 读写权限

- ro：只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作，如`docker run -d -P --name nginx02 -v juming-ngnix:/etc/nginx:ro nginx`

### 初识Dockerfile

Dockerfile就是用来构建docker镜像的构建文件的命令脚本。

通过脚本生成镜像，镜像是一层一层的，每个命令都是一层

- 创建一个dockerfile文件，名字可以随机建议Dockerfile
- 文件中的内容指令(大写）参数
- 每个命令就是一层

```shell
[root@reanon docker-test-volume]# vim dockerfile1
[root@reanon docker-test-volume]# cat dockerfile1 
FROM centos
# 这里是匿名挂载
# 将volume01、volume02挂载到容器内的根目录下
VOLUME ["volume01","volume02"]
CMD echo "----end----"
CMD /bin/bash
```

生成一个docker

- `docker build -f dockerfile1 -t reanon/centos:1.0 .`
  - 这里最后有个点

```shell
[root@reanon docker-test-volume]# docker build -f dockerfile1 -t reanon/centos:1.0 .
Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 0d120b6ccaa8
Step 2/4 : VOLUME ["volume01","volume02"]
 ---> Running in 71f5edae0fef
Removing intermediate container 71f5edae0fef
 ---> af6bf5877a50
Step 3/4 : CMD echo "----end----"
 ---> Running in d60403bcb1e7
Removing intermediate container d60403bcb1e7
 ---> b1365ab93354
Step 4/4 : CMD /bin/bash
 ---> Running in e7d2099a4eb7
Removing intermediate container e7d2099a4eb7
 ---> 6df2cf9fc6e4
Successfully built 6df2cf9fc6e4
Successfully tagged reanon/centos:1.0

# 查看镜像
[root@reanon docker-test-volume]# docker images
```

![image-20200926212839605](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926212839.png)

```shell
# 运行自己的镜像
[root@reanon docker-test-volume]# docker run -it 6df2cf9fc6e4 /bin/bash
[root@b4ea30ab1fbc /]# ls -l
```

![image-20200926213447752](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926213447.png)

查看卷挂载的路径

```shell
[root@reanon volumes]# docker inspect b4ea30ab1fbc
```

![image-20200926213844250](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200926213844.png)

### 数据卷容器

实现多个容器之间的数据共享

- --volumes-from：实现容器共享

![image-20200927110137431](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927110144.png)

```shell
# 启动容器
[root@reanon ~]# docker run -it --name=docker01  reanon/centos:1.0
# 退出容器：ctrl + p + q
[root@301f07a97728 /]# [root@reanon ~]# 
[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
301f07a97728        reanon/centos:1.0   "/bin/sh -c /bin/bash"   About a minute ago   Up About a minute                       docker01

# 启动一个新的容器，然后挂载到第一个容器  
[root@reanon ~]# docker run -it --name docker02 --volumes-from docker01 reanon/centos:1.0

# 在新容器内新建一个文件
[root@21bfc90122f0 /]# ls
bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var	   volume02
dev  home  lib64  media       opt  root  sbin  sys  usr  volume01
# 新建文件docker01 
[root@21bfc90122f0 /]# cd volume01
[root@21bfc90122f0 volume01]# touch docker02
[root@21bfc90122f0 volume01]# ls
docker02

# 退出容器，进入第一个容器，查看文件，发现文件同步了
[root@reanon ~]# docker exec -it docker01 /bin/bash
[root@301f07a97728 /]# cd /volume01
[root@301f07a97728 volume01]# ls
docker02
```

测试：删除docker01，查看一下docker02依旧可以访间这个文件

![image-20200927111937761](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927111937.png)

容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。

但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的!

## DockerFile 

### DockerFile介绍

dockerfile是用来构建dokcer镜像的文件的命令参数脚本!
构建步骤:

1. 编写一个dockerfile文件
2. docker build构建成为一个镜像
3. docker run运行镜像
4. docker push发布镜像（DockerHub、阿里云镜像仓库!)

查看一下官方是怎么做的

进入dockerHub的[centos镜像](https://registry.hub.docker.com/_/centos)，然后点击一个版本信息

![image-20200927133343990](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927133344.png)

![image-20200927133424417](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927133424.png)

### DockerFile 构建过程

基础知识：

1. 每个保留关键字（指令）都是必须是大写字母
2. 执行从上到下顺序执行
3. #表示注释
4. 每一个指令都会创建提交一个新的镜像层，并提交

![image-20200927135211010](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927135211.png)

dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单!
Docker镜像逐渐成为企业交付的标准，必须要掌握。
步骤:

1. DockerFile:构建文件，定义了一切的步骤，源代码
2. Dockerlmages :通过DockerFile构建生成的镜像，最终发布和运行的产品!
3. Docker容器︰容器就是镜像运行起来提供服务器

### DockerFile的常用指令

- FROM，指定基础镜像，从这里开始构建
- MLABELAINTAINER：表明镜像的作者。姓名+邮箱；将被遗弃，被LABEL代替
- RUN，构建镜像过程中需要执行的命令。可以有多条。
- ADD，将本地文件或目录拷贝到镜像的文件系统中。能解压特定格式文件，能将URL作为要拷贝的文件
- WORKDIR，设置工作目录
- VOLUME，添加数据卷
- EXPOSE，设置对外暴露的端口。
- CMD，添加启动容器时需要执行的命令。多条只有最后一条生效。可以在启动容器时被覆盖和修改。
- ENTRYPOINT，同CMD，但这个一定会被执行，不会被覆盖修改，可以追加命令。
- ENV，设置执行命令时的环境变量，并且在构建完成后，仍然生效
- ARG，设置只在构建过程中使用的环境变量，构建完成后，将消失
- COPY，将本地文件或目录拷贝到镜像的文件系统中。
- USER：指定以哪个用户的名义执行RUN, CMD 和ENTRYPOINT等命令

![Dockerfile文件指令](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927134733.png)

- ONBUILD，如果制作的镜像被另一个Dockerfile使用，将在那里被执行Docekrfile命令
- STOPSIGNAL：设置容器退出时发出的关闭信号。
- HEALTHCHECK，健康检查
- SHELL：更改执行shell命令的程序。Linux的默认shell是[“/bin/sh”, “-c”]，Windows的是[“cmd”, “/S”, “/C”]。

#### CMD

CMD 和ENTRYPOINT區別

- CMD，添加启动容器时需要执行的命令。多条**只有最后一条生效**。可以在启动容器时被覆盖和修改。
- ENTRYPOINT，同CMD，但这个一定会被执行，不会被覆盖修改，可以追加命令

构建镜像

```shell
# 编写dockerfile 文件
[root@reanon dockerfile]# vim dockerfile-cmd-test
FROM centos
CMD ["1s", "-a"]

# 构件镜像
[root@kuangshen dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .
```

开始测试

```shell
# run运行，发现我们的1s -a命令生效
[root@kuangshen dockerfile]# docker run dd8e4401d72f
..
.dockerenv
bin
dev
etc
home
lib
7ib64

# 想追加一个命令-l; 也即是 ls -al
# 而cmd的情况下-l替换了CMD ["1s"."-a"]命令，-l不是命令所以报错!
[root@reanon dockerfile]# docker run dd8e4401d72f -1
docker: Error response from daemon: OCI runtime create failed: container_7inux.go:349: starting
container process caused "exec: \"-7\": executable file not found in SPATH": unknown.

# 需要使用 ls -l -a 完整的命令才行
[root@reanon dockerfile]# docker run dd8e4401d72f -1
```

#### ENTRYPOINT

构建dockerfile

```shell
# 编写dockerfile 文件
[root@reanon dockerfile]# vim dockerfile-cmd-entrypoint
FROM centos
ENTRYPOINT ["1s", "-a"]

# 构件镜像
[root@kuangshen dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entrypoint-test .
```

开始测试

```shell
# run运行，发现我们的1s -a命令生效
[root@kuangshen dockerfile]# docker run 3c4c9621ed91
..
.dockerenv
bin
dev
etc
home
lib
7ib64

##我们的追加命令，是直接拼接在我们的ENTRYPOINT命令的后面!
[root@kuangshen dockerfile]# docker run 3c4c9621ed91 -l
total 56
drwxr-xr-xi root root 4096 May 15 13:15 .
drwxr-xr-xl root root 4096 May 1513:15
drwxr-xr-x5 root root340 May 15 13:15 dev
drwxr-xr-xl root root 4096 May 15 13:15 etc
drwxr-xr-x2 root root 4096 May 1l2019 home
```



### 创建自己的dockerfile

Docker Hub中99%镜像都是从这个基础镜像过来的FROM scratch，然后配置需要的软件和配置来进行的构建。

![image-20200927140959577](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200927140959.png)

开始创建

1. 编写dockerfile 文件
2. docker build 构建文件：`docker build -f [dockerfile文件路径] -t [镜像]:[tag] .`
   1. -f 指定dockerfile文件
   2. -t 指定生成的目标镜像
   3.  `.` 在当期目录下生成，不能忘记
3. 测试运行

#### 编写dockerfile 文件

```shell
[root@reanon dockerfile]# vim mydockerfile-centos
[root@reanon dockerfile]# cat mydockerfile-centos
FROM centos
MAINTAINER reanon<>

# 指定工作目录
ENV MYPATH /usr/local
WORKDIR $MYPATH

# 安装一些工具包
RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD echo $MYPATH
CMD echo "----end----"
CMD /bin/bash
```

#### docker build 构建文件

docker build 构建文件：`docker build -f [dockerfile文件路径] -t [镜像]:[tag] .`

1. -f 指定dockerfile文件
2. -t 指定生成的目标镜像
3. `.` 在当期目录下生成，不能忘记

```shell
# 开始构建镜像
[root@reanon dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .
Sending build context to Docker daemon  2.048kB
Step 1/10 : FROM centos
 ---> 0d120b6ccaa8
Step 2/10 : MAINTAINER reanon<>
...

Removing intermediate container 451e44668286
 ---> a1456f2704a1
Successfully built a1456f2704a1
Successfully tagged mycentos:0.1
```

这里的镜像文件复用了。

![image-20200928102353601](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928102353.png)

#### 测试自己的centos

```shell
# 启动
[root@reanon dockerfile]# docker run -it mycentos:0.1

# 一进入就是我们之前在WORDDIR
[root@f6a4e2b476cb local]# pwd
/usr/local

# 测试安装的工具包
[root@f6a4e2b476cb local]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
	inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
	...
     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

```

####  列出本地进行的变更

```shell
[root@reanon dockerfile]# docker history a1456f2704a1
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
a1456f2704a1        13 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "/bin…   0B   
14d50190f34a        13 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B   
1b92195fef37        13 minutes ago      /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B   
4ce0a4f2bb11        13 minutes ago      /bin/sh -c #(nop)  EXPOSE 80                    0B   
1dd122811db9        13 minutes ago      /bin/sh -c yum -y install net-tools             22.8MB              
216d27d11455        13 minutes ago      /bin/sh -c yum -y install vim                   57.2MB              
cc96cbd7ea10        13 minutes ago      /bin/sh -c #(nop) WORKDIR /usr/local            0B   
f673616769c7        13 minutes ago      /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B   
7dd0217de256        13 minutes ago      /bin/sh -c #(nop)  MAINTAINER reanon<>          0B   
0d120b6ccaa8        6 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B  
<missing>           6 weeks ago         /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B   
<missing>           6 weeks ago         /bin/sh -c #(nop) ADD file:538afc0c5c964ce0d…   215MB 
```

### 制作Tomcat 镜像

1、准备镜像文件tomcat压缩包，jdk的压缩包
2、编写dockerfile文件，官方命名`Dockerfil`，build 会自动寻找这个文件，就不需要-f 来指定。

```shell
[root@reanon ~]# cd /home/reanon/build/tomcat/
[root@reanon tomcat]# ls
apache-tomcat-9.0.38.tar.gz  jdk-8u251-linux-x64.tar.gz
[root@reanon tomcat]# vim Dockerfile
```

1、编写Dockerfile文件

```shell
FROM centos
MAINTAINER reanon<>
# 拷贝本地的readme.txt 文件到 /usr/local/readme.txt
COPY readme.txt /usr/local/readme.txt
# 将两个文件添加，添加时会自动解压
ADD jdk-8u251-linux-x64.tar.gz /usr/local
ADD apache-tomcat-9.0.38.tar.gz /usr/local
# 安装一下vim
RUN yum -y install vim
# 设置工作路径
ENV MYPATH /usr/local
WORKDIR $MYPATH
# 定义环境变量，ENV指定全局的环境
ENV JAVA_HOME /usr/local/jdk1.8.0_251
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.38
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.38
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
# 暴露端口
EXPOSE 8080
# 执行一个命令,打印日志到catalina.out
CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out
```

开始构建镜像

```shell
# 这里是标准的Dockerfile名，所以只要指定镜像名就行了
[root@reanon tomcat]# docker build -t diytomcat .
Sending build context to Docker daemon  206.4MB
Step 1/15 : FROM centos
 ---> 0d120b6ccaa8
Step 2/15 : MAINTAINER reanon<>
 ---> Using cache
...
Successfully built 518f3556167c
Successfully tagged diytomcat:latest

```

开始测试

- 指定端口映射：-p 9090:8080
- 容器命名：--name renaontomcat
- 目录挂载：-v /home/reanon/build/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps/test
- 日志目录挂载：-v /home/reanon/build/tomcat/tomcatlog/:/usr/local/apache-tomcat-9.0.38/log
- 指定启动的镜像：diytomcat

```shell
[root@reanon tomcat]# docker run -d -p 9090:8080 --name renaontomcat -v /home/reanon/build/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps/test -v /home/reanon/build/tomcat/tomcatlog/:/usr/local/apache-tomcat-9.0.38/logs diytomcat
043e59b5a7a2c429f1ae3c337577478cf34617830ba6e73ee86157953a7ed459
[root@reanon tomcat]# docker ps
```

访问测试

（这里有些问题的）

### 发布镜像

#### DockerHub

1. 在[DockerHub](https://hub.docker.com/)上注册账号

2. 在服务器上提交自己的镜像

   ```shell
   [root@reanon tomcat]# docker login --help
   
   Usage:	docker login [OPTIONS] [SERVER]
   
   Log in to a Docker registry.
   If no server is specified, the default is defined by the daemon.
   Options:
     -p, --password string   Password
         --password-stdin    Take the password from stdin
     -u, --username string   Username
   
   ```

3. 登录完毕之后，就可以提交镜像了

   ```shell
   root@reanon tomcat]# docker login -u reanon
   Password: 
   WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
   Configure a credential helper to remove this warning. See
   https://docs.docker.com/engine/reference/commandline/login/#credentials-store
   
   Login Succeeded
   [root@reanon tomcat]# 
   ```

4. docker push

   - 发布镜像，尽量带上版本号（也即是tag)

   ```shell
   # push 镜像到服务器上
   [root@kuangshen tomcat]# docker push reanon/diytomcat:1.0
   The push refers to repository [docker.io/library/diytomcat]
   fcc7fccb8e04: Preparing
   ...
   
   # push 镜像出问题
   The push refers to repository [docker.io/kuangshen/diytomcat2]
   An image does not exist locally with the tag: kuangshen/diytomcat2
   # 解决，增加一个tag
   [root@kuangshen tomcat]# docker tag f8559daf1fc2 kuangshen/tomcat:1.0
   ```

### 发布到阿里云

1. 登录阿里云

2. 找到容器镜像服务

3. 创建命名空间

   ![](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928173803.png)

4. 创建容器镜像

   ![image-20200928173945660](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928173945.png)

5. 查看基本信息

   点击仓库名称

   ![image-20200928174049157](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928174049.png)



### Dockerfile 小结

![image-20200928174533051](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928174533.png)



## Docker网络

### 理解Docker0

- 查看网络：`ip addr`

![image-20200928185002912](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928185003.png)

- 查看容器内部的ip

- ```shell
  # 运行一个容器
  [root@reanon tomcat]# docker run -d -P --name tomcat01 tomcat
  6146faf384efb1a138cd30e784051185edc6d85090648487122cfe9b47c51013
  
  # 直接在命令中执行查看ip地址
  # 查看容器的内部网络地址ip addr，发现容器启动的时候会得到一个eth0@if79 ip地址，docker分配的!
  [root@reanon tomcat]# docker exec -it tomcat01 ip addr
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      inet 127.0.0.1/8 scope host lo
         valid_lft forever preferred_lft forever
  78: eth0@if79: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
      link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
      inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
         valid_lft forever preferred_lft forever
  
  ```

### veth-pair 原理

- 我们发现这个容器带来网卡，都是一对对的
- veth-pair就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连
- 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备的
- openstac，Docker容器之间的连接，OVS的连接，都是使用veth-pair 技术

1、我们每启动一个docker容器,Idocker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0桥接模式，使用的技术是 veth-pair技术。

再次测试 ip addr

![image-20200928191046028](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928191046.png)

2、在启动一个容器测试，发现又多了一对网卡



3、我们来测试下 tomcat01和tomcat 02是否可以ping通 

```shell
[root@kuangshen/]# docker exec -it tomcat02 ping 172.18.0.2

# 结论:容器和容器之间是可以互相ping通的!
```

![image-20200928192103506](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928192103.png)

结论：tomcat01和tomcat02是公用的一个路由器：docker0。
所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP.

![image-20200928192524595](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200928192524.png)

Docker使用的是Linux的桥接，宿主机中是一个Dokcer容器的网桥 docker0。

### 容器互联 ：--link

思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来进行访问容器?

```shell
[root@kuangshen/]# docker exec -it tomcat02 ping tomcat01
ping: tomcato1: Name or service not known
# 如何可以解决呢?

# 通过--link解决网络连通问题
[root@kuangshen/]# docker run -d -P --name tomcat03 --link tomcat02 tomcat
5ca72d80ebb048d3560df1400af03130f37ece244be2a54884336aace2106884
[root@kuangshen/]# docker exec -it tomcat03 ping tomcat02
PING tomcat02 (172.18.0.3）56(84) bytes of data.
64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.100 ms
64 bytes from tomcat02 (172.18.0.3): icmp_seq=2 ttl=64 time=0.066ms
64 bytes from tomcat02 (172.18.0.3): icmp_seq=3 ttl=64 time=0.067 ms
c
--- tomcat02 ping statistics ---
3 packets transmitted,3 received，0% packet loss,time 1000ms
rtt min/avg/max/mdev_= 0.066/0.077/0.100/0.018 ms

# 反向不能ping通
[root@kuangshen/]# docker exec -it tomcat02 ping tomcat03
ping: tomcato3: Name or service not known
```

其实这个tomcat03就是在本地配置了tomcat02的配置

```shell
# 查看hosts配置，在这里发现原理
# hosts 地址映射的文件
[root@kuangshen/]# docker exec -it tomcat03 cat /etc/hosts
127.0.0.1loca7host
::1 localhost ip6-localhost ip6-loopback
fe00::o ip6-localnet
ff00::o ip6-mcastprefix
ff02::1 ip6-a1lnodes
ff02::2 ip6-a7lrouters
172.18.0.3  tomcat02 312857784cd4  # 这里配置了Tomcat02
172.18.0.4  5ca72d80ebbo

```

本质探究 

- --link 就是我们在hosts配置中增加了一个172.18.0.3 tomcat02 312857784cd4
- 已经不建议使用--link了!
- docker0问题：它不支持容器名直接访问!

### 自定义网络

####  网络模式

bridge：桥接（默认，自己创建也是用bridge模式）

none：不配置网络

host：主机模式，与宿主机共享模式

container：容器网络连通（用得少，局限很大）

![image-20200929084358591](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929084358.png)

启动容器时，有默认的网络参数：`[--net bridge]`

```shell
# 我们直接启动的命令--net bridge，而这个就是我们的docker0
docker run -d -p --name tomcato1 tomcat
docker run -d -p --name tomcat01 --net bridge tomcat

```

#### 创建自定义网络

```shell
[root@reanon ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
ddee30ed97521858812580841fc0133e9ff2d4f1284ef288c07b94d87d496fa7
[root@reanon ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b2f6f48ffc5b        bridge              bridge              local
a885a6a7bda1        host                host                local
ddee30ed9752        mynet               bridge              local
d116b4d2c36a        none                null                local

# 查看自定义的网络
[root@reanon ~]# docker network inspect mynet
```

![image-20200929085919111](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929085919.png)

#### 自定义网络创建容器

- 指定网络创建：`--net mynet`
- 查看网络： `docker network inspect [mynet]`

```shell
# 指定网络创建容器
[root@reanon ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat
295346314e149e660c55176f6b91a8a128b8a9920c15a03b2aa044fcf501409c
[root@reanon ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat
1c604eb104264be7fc6cd2bb42146a79610aeee59b4ecc7cb332b1bfc9dd8616
# 查看定义的网络
[root@reanon ~]# docker network inspect mynet
```

![image-20200929090655718](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929090655.png)

#### ping 容器名

```shell 
# 使用网络ping 
[root@reanon ~]# docker exec -it tomcat-net-01 ping 192.168.0.3
PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.109 ms
...
rtt min/avg/max/mdev = 0.073/0.091/0.109/0.018 ms

# 使用容器名ping
# 现在不使用--link也可以ping 名字了
[root@reanon ~]# docker exec -it tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
...
rtt min/avg/max/mdev = 0.050/0.068/0.080/0.015 ms 
```

我们自定义网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络!

好处:

- redis -不同的集群使用不同的网络，保证集群是安全和健康的
- mysql -不同的集群使用不同的网络，保证集群是安全和健康的

### 网络连通



```shell
# 在docker0 上创建容器
[root@reanon ~]# docker run -d -P --name tomcat01 tomcat
4828d3f854d5c014f3049266c552e980f90457355d7552f191cffe9b95f9898f
[root@reanon ~]# docker run -d -P --name tomcat02 tomcat
cfe090977fe8ba6de191c3f6e4a5a0d8a41950e73330ba677edacdda76f9020a

[root@reanon ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
cfe090977fe8        tomcat              "catalina.sh run"   10 seconds ago      Up 9 seconds        0.0.0.0:32775->8080/tcp   tomcat02
4828d3f854d5        tomcat              "catalina.sh run"   15 seconds ago      Up 14 seconds       0.0.0.0:32774->8080/tcp   tomcat01
1c604eb10426        tomcat              "catalina.sh run"   34 minutes ago      Up 34 minutes       0.0.0.0:32773->8080/tcp   tomcat-net-02
295346314e14        tomcat              "catalina.sh run"   35 minutes ago      Up 34 minutes       0.0.0.0:32772->8080/tcp   tomcat-net-01
# 不同网络直接无法ping通
[root@reanon ~]# docker exec -it tomcat01 ping tomcat-net-01
ping: tomcat-net-01: Name or service not known

```

这里想要连通tomcat-01 和tomcat-net-01

![image-20200929093652480](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929093652.png)

#### docker network connect 

- docker network connect [OPTIONS] NETWORK CONTAINER

```shell
# 连通网络mynet 到容器tomcat01
[root@reanon ~]# docker network connect mynet tomcat01
# 检查自定义网络的变化
[root@reanon ~]# docker network inspect mynet
```

连通之后就是将tomcat 01放到了mynet网络下；于是tomcat01一个容器有了两个ip地址

![image-20200929094455778](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200929094455.png)

```shell
# 再次ping tomcat01，可以ping 通
[root@reanon ~]# docker exec -it tomcat01 ping tomcat-net-01
PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.
...
rtt min/avg/max/mdev = 0.071/0.078/0.083/0.005 ms

# tomcat02 依旧无法ping通过
[root@reanon ~]# docker exec -it tomcat02 ping tomcat-net-01
ping: tomcat-net-01: Name or service not known
```

结论:假设要跨网络操作别人，就需要使用`docker network connect`连通。



Docker Compose



Docker Swarm



CI/CD之Jenkins