# 归并排序（MERGE-SORT）

利用归并的思想实现的排序方法，该算法采用经典的**分治（divide-and-conquer）**策略（

- 分治法将问题分(divide)成一些小的问题然后递归求解
- 而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。

## 时间复杂度$O(nlogn)$

- 快速、**归并**、希尔、堆基于二分思想，log以2为底，平均时间复杂度为$O(nlogn)$（一遍找元素$O(n)$，一遍找位置$O(logn$)）

| 类别 | 排序法 |  最好时间  |  平均时间  |  最差情形  | 稳定度 | 额外空间 | 备注      |
| :--: | :----: | :--------: | :--------: | :--------: | :----: | :------: | --------- |
|  >=  |  归并  | $O(nlogn)$ | $O(nlogn)$ | $O(nlogn)$ |  稳定  |  $O(1)$  | n大时较好 |

## 排序规则

1. 分解：分解等排序的n个元素的序列成各具n/2个元素的两个子序列；
2. 解决：使用归并排序递归地排序两个子序列；
3. （合并：合并两个已排序的子序列以产生已排序的答案。

当待排序的序列长度为1时，递归"开始回升"，在这种情况下不根做任何工作，因为长度为1的每个序列都已排好序。

![image-20200918170851839](https://gitee.com/Reanon/upload-markdown-img/raw/master/img/20200918170851.png)

## 核心代码

归并排序算法的关键操作是"**合并**"步骤中两个已排序序列的合并。我们可以通过调用一个辅助过程`Merge(A, p, q, r)`来完成合并，其中A是一个数组，p、q和r是数组下标，满足 `p ≤ q <` r。该过程假设子数组A[p..q]和A[q+1..r]都已排好序。它合并这两个子数组形成单一的已排好序的子数组并代替当前的子数组A[p..r]。

